<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ICU 3.8: uiter.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>uiter.h File Reference</h1>C API: Unicode Character Iteration. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="utypes_8h-source.html">unicode/utypes.h</a>&quot;</code><br>

<p>
<a href="uiter_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUCharIterator.html">UCharIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C API for code unit iteration.  <a href="structUCharIterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#afcf208dc06e96d1a48221de2cd96f21">UITER_NO_STATE</a>&nbsp;&nbsp;&nbsp;((uint32_t)0xffffffff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> getState() indicating an error or an unknown state.  <a href="#afcf208dc06e96d1a48221de2cd96f21"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="structUCharIterator.html">UCharIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#7be461ccdd9257329604393ce0ab982f">UCharIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C typedef for struct <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a>.  <a href="#7be461ccdd9257329604393ce0ab982f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int32_t U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#1e20dbf7ee31665308060414ab33896d">UCharIteratorGetIndex</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, <a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a> origin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#3d8274db3ff99ebb6bb2d0784c9cd7ca" title="(public) Returns the current position or the start or limit index of the iteration...">UCharIterator.getIndex()</a>.  <a href="#1e20dbf7ee31665308060414ab33896d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int32_t U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#685b93cd5dd64a1c28ff243de0970e66">UCharIteratorMove</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, int32_t delta, <a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a> origin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#085355b29925cbf9170e364e9aef7bc5" title="(public) Moves the current position relative to the start or limit of the iteration...">UCharIterator.move()</a>.  <a href="#685b93cd5dd64a1c28ff243de0970e66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#8df87a03c91a3e20012949de43c59381">UCharIteratorHasNext</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#c6dc92d309ace93dc07ad9092e807578" title="(public) Check if current() and next() can still return another code unit.">UCharIterator.hasNext()</a>.  <a href="#8df87a03c91a3e20012949de43c59381"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#238ebeaecab0965abb28c6732b151ed1">UCharIteratorHasPrevious</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#5a5d536cc7275cdba8b6b2487a4f75a6" title="(public) Check if previous() can still return another code unit.">UCharIterator.hasPrevious()</a>.  <a href="#238ebeaecab0965abb28c6732b151ed1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#e4162b85c1ce61e161e0d6832fb5ae25">UCharIteratorCurrent</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#c247dee1b3e3e6fec6688f9dcb5bc1c6" title="(public) Return the code unit at the current position, or U_SENTINEL if there is...">UCharIterator.current()</a>.  <a href="#e4162b85c1ce61e161e0d6832fb5ae25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#8e9ad76bae5c0639e7c2dde67982ed73">UCharIteratorNext</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#ae26243728a62e6a13ed2008972afb50" title="(public) Return the code unit at the current index and increment the index (post-increment...">UCharIterator.next()</a>.  <a href="#8e9ad76bae5c0639e7c2dde67982ed73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#e84be008356b2c440211befa29f30af0">UCharIteratorPrevious</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#65cd2a527c6abe69a0f37a368ce51cfb" title="(public) Decrement the index and return the code unit from there (pre-decrement,...">UCharIterator.previous()</a>.  <a href="#e84be008356b2c440211befa29f30af0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int32_t U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#80d5b61426ccc309c318963ecadd9fe0">UCharIteratorReserved</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, int32_t something)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#94b7ab71aadd2cbafa7394c1102cdf2f" title="(public) Reserved for future use.">UCharIterator.reservedFn()</a>.  <a href="#80d5b61426ccc309c318963ecadd9fe0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uint32_t U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#c89c7dfd00ad111aae63f094cc427b5a">UCharIteratorGetState</a> (const <a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#dbdac3a7450c4b9344aad58b1e72d1b4" title="(public) Return the state of the iterator, to be restored later with setState().">UCharIterator.getState()</a>.  <a href="#c89c7dfd00ad111aae63f094cc427b5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void U_CALLCONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#51424ac3e57c7d9502f84a048186c99a">UCharIteratorSetState</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, uint32_t state, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type declaration for <a class="el" href="structUCharIterator.html#d216d787e1125bc81b49686c7700b52f" title="(public) Restore the iterator state from the state word from a call to getState()...">UCharIterator.setState()</a>.  <a href="#51424ac3e57c7d9502f84a048186c99a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a> { <br>
&nbsp;&nbsp;<b>UITER_START</b>, 
<b>UITER_CURRENT</b>, 
<b>UITER_LIMIT</b>, 
<b>UITER_ZERO</b>, 
<br>
&nbsp;&nbsp;<b>UITER_LENGTH</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Origin constants for <a class="el" href="structUCharIterator.html#3d8274db3ff99ebb6bb2d0784c9cd7ca" title="(public) Returns the current position or the start or limit index of the iteration...">UCharIterator.getIndex()</a> and <a class="el" href="structUCharIterator.html#085355b29925cbf9170e364e9aef7bc5" title="(public) Moves the current position relative to the start or limit of the iteration...">UCharIterator.move()</a>.  <a href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="uiter_8h.html#61dadd085c1777f559549e05962b2c9ec15b49df57fe9ae213b64ef3fc05fd3a">UITER_UNKNOWN_INDEX</a> = -2
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constants for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a>.  <a href="uiter_8h.html#61dadd085c1777f559549e05962b2c9e">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#126d33b7d879ca2f8427004116c0340b">uiter_current32</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the code point at the current index.  <a href="#126d33b7d879ca2f8427004116c0340b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#5f5c726c5eba7d3c8fbc7238562be0cf">uiter_next32</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the next code point.  <a href="#5f5c726c5eba7d3c8fbc7238562be0cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#9225fa4316a792ba1585fc2ea8197afb">uiter_previous32</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the previous code point.  <a href="#9225fa4316a792ba1585fc2ea8197afb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#561ede314e6f46cd7662a0f309f9b18a">uiter_getState</a> (const <a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the "state" of the iterator in the form of a single 32-bit word.  <a href="#561ede314e6f46cd7662a0f309f9b18a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#6cc978207c5f99588d5b915b7c85ebd1">uiter_setState</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, uint32_t state, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the "state" of the iterator using a state word from a getState() call.  <a href="#6cc978207c5f99588d5b915b7c85ebd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#373dbf81553f2f3553b64c31e3c6147f">uiter_setString</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, const UChar *s, int32_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a string.  <a href="#373dbf81553f2f3553b64c31e3c6147f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#91a1ae4d9d562077b5c06d7ba75c7ebd">uiter_setUTF16BE</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, const char *s, int32_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a UTF-16BE string (byte vector with a big-endian pair of bytes per UChar).  <a href="#91a1ae4d9d562077b5c06d7ba75c7ebd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="uiter_8h.html#a221e8b7a4eb6f47ff03c80a09ae8a02">uiter_setUTF8</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, const char *s, int32_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a UTF-8 string.  <a href="#a221e8b7a4eb6f47ff03c80a09ae8a02"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
C API: Unicode Character Iteration. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>

<p>Definition in file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="afcf208dc06e96d1a48221de2cd96f21"></a><!-- doxytag: member="uiter.h::UITER_NO_STATE" ref="afcf208dc06e96d1a48221de2cd96f21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UITER_NO_STATE&nbsp;&nbsp;&nbsp;((uint32_t)0xffffffff)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> getState() indicating an error or an unknown state. 
<p>
Returned by <a class="el" href="uiter_8h.html#561ede314e6f46cd7662a0f309f9b18a" title="Get the &quot;state&quot; of the iterator in the form of a single 32-bit word.">uiter_getState()</a>/UCharIteratorGetState when an error occurs. Also, some <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> implementations may not be able to return a valid state for each position. This will be clearly documented for each such iterator (none of the public ones here).<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001111">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00084">84</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="7be461ccdd9257329604393ce0ab982f"></a><!-- doxytag: member="uiter.h::UCharIterator" ref="7be461ccdd9257329604393ce0ab982f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUCharIterator.html">UCharIterator</a> <a class="el" href="structUCharIterator.html">UCharIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C typedef for struct <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a>. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001108">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00041">41</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e4162b85c1ce61e161e0d6832fb5ae25"></a><!-- doxytag: member="uiter.h::UCharIteratorCurrent" ref="e4162b85c1ce61e161e0d6832fb5ae25" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV <a class="el" href="uiter_8h.html#e4162b85c1ce61e161e0d6832fb5ae25">UCharIteratorCurrent</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#c247dee1b3e3e6fec6688f9dcb5bc1c6" title="(public) Return the code unit at the current position, or U_SENTINEL if there is...">UCharIterator.current()</a>. 
<p>
Return the code unit at the current position, or U_SENTINEL if there is none (index is at the limit).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current code unit</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001116">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00186">186</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1e20dbf7ee31665308060414ab33896d"></a><!-- doxytag: member="uiter.h::UCharIteratorGetIndex" ref="1e20dbf7ee31665308060414ab33896d" args="(UCharIterator *iter, UCharIteratorOrigin origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t U_CALLCONV <a class="el" href="uiter_8h.html#1e20dbf7ee31665308060414ab33896d">UCharIteratorGetIndex</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, <a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a> origin)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#3d8274db3ff99ebb6bb2d0784c9cd7ca" title="(public) Returns the current position or the start or limit index of the iteration...">UCharIterator.getIndex()</a>. 
<p>
Gets the current position, or the start or limit of the iteration range.<p>
This function may perform slowly for UITER_CURRENT after setState() was called, or for UITER_LENGTH, because an iterator implementation may have to count UChars if the underlying storage is not UTF-16.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>get the 0, start, limit, length, or current index </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the requested index, or U_SENTINEL in an error condition</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766" title="Origin constants for UCharIterator.getIndex() and UCharIterator.move().">UCharIteratorOrigin</a> <p>
<a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001112">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00105">105</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c89c7dfd00ad111aae63f094cc427b5a"></a><!-- doxytag: member="uiter.h::UCharIteratorGetState" ref="c89c7dfd00ad111aae63f094cc427b5a" args="(const UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t U_CALLCONV <a class="el" href="uiter_8h.html#c89c7dfd00ad111aae63f094cc427b5a">UCharIteratorGetState</a>(const <a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#dbdac3a7450c4b9344aad58b1e72d1b4" title="(public) Return the state of the iterator, to be restored later with setState().">UCharIterator.getState()</a>. 
<p>
Get the "state" of the iterator in the form of a single 32-bit word. It is recommended that the state value be calculated to be as small as is feasible. For strings with limited lengths, fewer than 32 bits may be sufficient.<p>
This is used together with setState()/UCharIteratorSetState to save and restore the iterator position more efficiently than with getIndex()/move().<p>
The iterator state is defined as a uint32_t value because it is designed for use in <a class="el" href="ucol_8h.html#8c8ed92bb13577d6cd9a129b38a05d69" title="Gets the next count bytes of a sort key.">ucol_nextSortKeyPart()</a> which provides 32 bits to store the state of the character iterator.<p>
With some <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> implementations (e.g., UTF-8), getting and setting the UTF-16 index with existing functions (getIndex(UITER_CURRENT) followed by move(pos, UITER_ZERO)) is possible but relatively slow because the iterator has to "walk" from a known index to the requested one. This takes more time the farther it needs to go.<p>
An opaque state value allows an iterator implementation to provide an internal index (UTF-8: the source byte array index) for fast, constant-time restoration.<p>
After calling setState(), a getIndex(UITER_CURRENT) may be slow because the UTF-16 index may not be restored as well, but the iterator can deliver the correct text contents and move relative to the current position without performance degradation.<p>
Some <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> implementations may not be able to return a valid state for each position, in which case they return UITER_NO_STATE instead. This will be clearly documented for each such iterator (none of the public ones here).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the state word</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#51424ac3e57c7d9502f84a048186c99a" title="Function type declaration for UCharIterator.setState().">UCharIteratorSetState</a> <p>
<a class="el" href="uiter_8h.html#afcf208dc06e96d1a48221de2cd96f21" title="Constant for UCharIterator getState() indicating an error or an unknown state.">UITER_NO_STATE</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001120">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00279">279</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8df87a03c91a3e20012949de43c59381"></a><!-- doxytag: member="uiter.h::UCharIteratorHasNext" ref="8df87a03c91a3e20012949de43c59381" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> U_CALLCONV <a class="el" href="uiter_8h.html#8df87a03c91a3e20012949de43c59381">UCharIteratorHasNext</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#c6dc92d309ace93dc07ad9092e807578" title="(public) Check if current() and next() can still return another code unit.">UCharIterator.hasNext()</a>. 
<p>
Check if current() and next() can still return another code unit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value for whether current() and next() can still return another code unit</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001114">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00157">157</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="238ebeaecab0965abb28c6732b151ed1"></a><!-- doxytag: member="uiter.h::UCharIteratorHasPrevious" ref="238ebeaecab0965abb28c6732b151ed1" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> U_CALLCONV <a class="el" href="uiter_8h.html#238ebeaecab0965abb28c6732b151ed1">UCharIteratorHasPrevious</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#5a5d536cc7275cdba8b6b2487a4f75a6" title="(public) Check if previous() can still return another code unit.">UCharIterator.hasPrevious()</a>. 
<p>
Check if previous() can still return another code unit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value for whether previous() can still return another code unit</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001115">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00171">171</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="685b93cd5dd64a1c28ff243de0970e66"></a><!-- doxytag: member="uiter.h::UCharIteratorMove" ref="685b93cd5dd64a1c28ff243de0970e66" args="(UCharIterator *iter, int32_t delta, UCharIteratorOrigin origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t U_CALLCONV <a class="el" href="uiter_8h.html#685b93cd5dd64a1c28ff243de0970e66">UCharIteratorMove</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, int32_t delta, <a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a> origin)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#085355b29925cbf9170e364e9aef7bc5" title="(public) Moves the current position relative to the start or limit of the iteration...">UCharIterator.move()</a>. 
<p>
Use iter-&gt;move(iter, index, UITER_ZERO) like CharacterIterator::setIndex(index).<p>
Moves the current position relative to the start or limit of the iteration range, or relative to the current position itself. The movement is expressed in numbers of code units forward or backward by specifying a positive or negative delta. Out of bounds movement will be pinned to the start or limit.<p>
This function may perform slowly for moving relative to UITER_LENGTH because an iterator implementation may have to count the rest of the UChars if the native storage is not UTF-16.<p>
When moving relative to the limit or length, or relative to the current position after setState() was called, move() may return UITER_UNKNOWN_INDEX (-2) to avoid an inefficient determination of the actual UTF-16 index. The actual index can be determined with getIndex(UITER_CURRENT) which will count the UChars if necessary. See UITER_UNKNOWN_INDEX for details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delta</em>&nbsp;</td><td>can be positive, zero, or negative </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>move relative to the 0, start, limit, length, or current index </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new index, or U_SENTINEL on an error condition, or UITER_UNKNOWN_INDEX when the index is not known.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766" title="Origin constants for UCharIterator.getIndex() and UCharIterator.move().">UCharIteratorOrigin</a> <p>
<a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#61dadd085c1777f559549e05962b2c9ec15b49df57fe9ae213b64ef3fc05fd3a" title="Constant value that may be returned by UCharIteratorMove indicating that the final...">UITER_UNKNOWN_INDEX</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001113">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00142">142</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8e9ad76bae5c0639e7c2dde67982ed73"></a><!-- doxytag: member="uiter.h::UCharIteratorNext" ref="8e9ad76bae5c0639e7c2dde67982ed73" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV <a class="el" href="uiter_8h.html#8e9ad76bae5c0639e7c2dde67982ed73">UCharIteratorNext</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#ae26243728a62e6a13ed2008972afb50" title="(public) Return the code unit at the current index and increment the index (post-increment...">UCharIterator.next()</a>. 
<p>
Return the code unit at the current index and increment the index (post-increment, like s[i++]), or return U_SENTINEL if there is none (index is at the limit).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current code unit (and post-increment the current index)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001117">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00202">202</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e84be008356b2c440211befa29f30af0"></a><!-- doxytag: member="uiter.h::UCharIteratorPrevious" ref="e84be008356b2c440211befa29f30af0" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_CALLCONV <a class="el" href="uiter_8h.html#e84be008356b2c440211befa29f30af0">UCharIteratorPrevious</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#65cd2a527c6abe69a0f37a368ce51cfb" title="(public) Decrement the index and return the code unit from there (pre-decrement,...">UCharIterator.previous()</a>. 
<p>
Decrement the index and return the code unit from there (pre-decrement, like s[--i]), or return U_SENTINEL if there is none (index is at the start).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the previous code unit (after pre-decrementing the current index)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001118">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00218">218</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="80d5b61426ccc309c318963ecadd9fe0"></a><!-- doxytag: member="uiter.h::UCharIteratorReserved" ref="80d5b61426ccc309c318963ecadd9fe0" args="(UCharIterator *iter, int32_t something)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t U_CALLCONV <a class="el" href="uiter_8h.html#80d5b61426ccc309c318963ecadd9fe0">UCharIteratorReserved</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, int32_t something)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#94b7ab71aadd2cbafa7394c1102cdf2f" title="(public) Reserved for future use.">UCharIterator.reservedFn()</a>. 
<p>
Reserved for future use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>something</em>&nbsp;</td><td>some integer argument </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>some integer</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001119">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00232">232</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="51424ac3e57c7d9502f84a048186c99a"></a><!-- doxytag: member="uiter.h::UCharIteratorSetState" ref="51424ac3e57c7d9502f84a048186c99a" args="(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void U_CALLCONV <a class="el" href="uiter_8h.html#51424ac3e57c7d9502f84a048186c99a">UCharIteratorSetState</a>(<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter, uint32_t state, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function type declaration for <a class="el" href="structUCharIterator.html#d216d787e1125bc81b49686c7700b52f" title="(public) Restore the iterator state from the state word from a call to getState()...">UCharIterator.setState()</a>. 
<p>
Restore the "state" of the iterator using a state word from a getState() call. The iterator object need not be the same one as for which getState() was called, but it must be of the same type (set up using the same uiter_setXYZ function) and it must iterate over the same string (binary identical regardless of memory address). For more about the state word see UCharIteratorGetState.<p>
After calling setState(), a getIndex(UITER_CURRENT) may be slow because the UTF-16 index may not be restored as well, but the iterator can deliver the correct text contents and move relative to the current position without performance degradation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>the state word from a getState() call on a same-type, same-string iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#c89c7dfd00ad111aae63f094cc427b5a" title="Function type declaration for UCharIterator.getState().">UCharIteratorGetState</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001121">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00307">307</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="61dadd085c1777f559549e05962b2c9e"></a><!-- doxytag: member="uiter.h::@5" ref="61dadd085c1777f559549e05962b2c9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constants for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a>. 
<p>
<dl compact><dt><b>Stable:</b></dt><dd>ICU 2.6 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="61dadd085c1777f559549e05962b2c9ec15b49df57fe9ae213b64ef3fc05fd3a"></a><!-- doxytag: member="UITER_UNKNOWN_INDEX" ref="61dadd085c1777f559549e05962b2c9ec15b49df57fe9ae213b64ef3fc05fd3a" args="" -->UITER_UNKNOWN_INDEX</em>&nbsp;</td><td>
Constant value that may be returned by UCharIteratorMove indicating that the final UTF-16 index is not known, but that the move succeeded. 
<p>
This can occur when moving relative to limit or length, or when moving relative to the current index after a setState() when the current UTF-16 index is not known.<p>
It would be very inefficient to have to count from the beginning of the text just to get the current/limit/length index after moving relative to it. The actual index can be determined with getIndex(UITER_CURRENT) which will count the UChars if necessary.<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001131">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00054">54</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb93256d32b49b35a49affe3db4e5766"></a><!-- doxytag: member="uiter.h::UCharIteratorOrigin" ref="cb93256d32b49b35a49affe3db4e5766" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="uiter_8h.html#cb93256d32b49b35a49affe3db4e5766">UCharIteratorOrigin</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Origin constants for <a class="el" href="structUCharIterator.html#3d8274db3ff99ebb6bb2d0784c9cd7ca" title="(public) Returns the current position or the start or limit index of the iteration...">UCharIterator.getIndex()</a> and <a class="el" href="structUCharIterator.html#085355b29925cbf9170e364e9aef7bc5" title="(public) Moves the current position relative to the start or limit of the iteration...">UCharIterator.move()</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="uiter_8h.html#685b93cd5dd64a1c28ff243de0970e66" title="Function type declaration for UCharIterator.move().">UCharIteratorMove</a> <p>
<a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001109">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="uiter_8h-source.html#l00049">49</a> of file <a class="el" href="uiter_8h-source.html">uiter.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="126d33b7d879ca2f8427004116c0340b"></a><!-- doxytag: member="uiter.h::uiter_current32" ref="126d33b7d879ca2f8427004116c0340b" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> uiter_current32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the code point at the current index. 
<p>
Return the code point that includes the code unit at the current position, or U_SENTINEL if there is none (index is at the limit). If the current code unit is a lead or trail surrogate, then the following or preceding surrogate is used to form the code point value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current code point</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="utf16_8h.html#a354b12f5f755fe734f957cde6d68bbe" title="Get a code point from a string at a random-access offset, without changing the offset...">U16_GET</a> <p>
<a class="el" href="classUnicodeString.html#9ca80740ef5199cf1809c66a4ef6ba3d" title="Return the code point that contains the code unit at offset offset.">UnicodeString::char32At()</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001123">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="561ede314e6f46cd7662a0f309f9b18a"></a><!-- doxytag: member="uiter.h::uiter_getState" ref="561ede314e6f46cd7662a0f309f9b18a" args="(const UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uiter_getState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the "state" of the iterator in the form of a single 32-bit word. 
<p>
This is a convenience function that calls iter-&gt;getState(iter) if iter-&gt;getState is not NULL; if it is NULL or any other error occurs, then UITER_NO_STATE is returned.<p>
Some <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> implementations may not be able to return a valid state for each position, in which case they return UITER_NO_STATE instead. This will be clearly documented for each such iterator (none of the public ones here).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the state word</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#c89c7dfd00ad111aae63f094cc427b5a" title="Function type declaration for UCharIterator.getState().">UCharIteratorGetState</a> <p>
<a class="el" href="uiter_8h.html#afcf208dc06e96d1a48221de2cd96f21" title="Constant for UCharIterator getState() indicating an error or an unknown state.">UITER_NO_STATE</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001126">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f5c726c5eba7d3c8fbc7238562be0cf"></a><!-- doxytag: member="uiter.h::uiter_next32" ref="5f5c726c5eba7d3c8fbc7238562be0cf" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> uiter_next32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the next code point. 
<p>
Return the code point at the current index and increment the index (post-increment, like s[i++]), or return U_SENTINEL if there is none (index is at the limit).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current code point (and post-increment the current index)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="utf16_8h.html#844bb48486904fdca40c8b883e9c80ee" title="Get a code point from a string at a code point boundary offset, and advance the offset...">U16_NEXT</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001124">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="9225fa4316a792ba1585fc2ea8197afb"></a><!-- doxytag: member="uiter.h::uiter_previous32" ref="9225fa4316a792ba1585fc2ea8197afb" args="(UCharIterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> uiter_previous32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function for <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to get the previous code point. 
<p>
Decrement the index and return the code point from there (pre-decrement, like s[--i]), or return U_SENTINEL if there is none (index is at the start).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the previous code point (after pre-decrementing the current index)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="utf16_8h.html#592fa1f80da119e1c4565dc9193c18d9" title="Move the string offset from one code point boundary to the previous one and get the...">U16_PREV</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001125">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cc978207c5f99588d5b915b7c85ebd1"></a><!-- doxytag: member="uiter.h::uiter_setState" ref="6cc978207c5f99588d5b915b7c85ebd1" args="(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uiter_setState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restore the "state" of the iterator using a state word from a getState() call. 
<p>
This is a convenience function that calls iter-&gt;setState(iter, state, pErrorCode) if iter-&gt;setState is not NULL; if it is NULL, then U_UNSUPPORTED_ERROR is set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure ("this pointer") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>the state word from a getState() call on a same-type, same-string iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#51424ac3e57c7d9502f84a048186c99a" title="Function type declaration for UCharIterator.setState().">UCharIteratorSetState</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001127">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="373dbf81553f2f3553b64c31e3c6147f"></a><!-- doxytag: member="uiter.h::uiter_setString" ref="373dbf81553f2f3553b64c31e3c6147f" args="(UCharIterator *iter, const UChar *s, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uiter_setString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a string. 
<p>
Sets the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> function pointers for iteration over the string s with iteration boundaries start=index=0 and length=limit=string length. The "provider" may set the start, index, and limit values at any time within the range 0..length. The length field will be ignored.<p>
The string pointer s is set into <a class="el" href="structUCharIterator.html#33f323cfae0faa809f047874d2021fe6" title="(protected) Pointer to string or wrapped object or similar.">UCharIterator.context</a> without copying or reallocating the string contents.<p>
getState() simply returns the current index. move() will always return the final index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure to be set for iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>String to iterate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of s, or -1 if NUL-terminated</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001128">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="91a1ae4d9d562077b5c06d7ba75c7ebd"></a><!-- doxytag: member="uiter.h::uiter_setUTF16BE" ref="91a1ae4d9d562077b5c06d7ba75c7ebd" args="(UCharIterator *iter, const char *s, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uiter_setUTF16BE           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a UTF-16BE string (byte vector with a big-endian pair of bytes per UChar). 
<p>
Everything works just like with a normal UChar iterator (uiter_setString), except that UChars are assembled from byte pairs, and that the length argument here indicates an even number of bytes.<p>
getState() simply returns the current index. move() will always return the final index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure to be set for iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>UTF-16BE string to iterate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of s as an even number of bytes, or -1 if NUL-terminated (NUL means pair of 0 bytes at even index from s)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> <p>
<a class="el" href="uiter_8h.html#373dbf81553f2f3553b64c31e3c6147f" title="Set up a UCharIterator to iterate over a string.">uiter_setString</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001129">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a221e8b7a4eb6f47ff03c80a09ae8a02"></a><!-- doxytag: member="uiter.h::uiter_setUTF8" ref="a221e8b7a4eb6f47ff03c80a09ae8a02" args="(UCharIterator *iter, const char *s, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uiter_setUTF8           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> to iterate over a UTF-8 string. 
<p>
Sets the <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> function pointers for iteration over the UTF-8 string s with UTF-8 iteration boundaries 0 and length. The implementation counts the UTF-16 index on the fly and lazily evaluates the UTF-16 length of the text.<p>
The start field is used as the UTF-8 offset, the limit field as the UTF-8 length. When the reservedField is not 0, then it contains a supplementary code point and the UTF-16 index is between the two corresponding surrogates. At that point, the UTF-8 index is behind that code point.<p>
The UTF-8 string pointer s is set into <a class="el" href="structUCharIterator.html#33f323cfae0faa809f047874d2021fe6" title="(protected) Pointer to string or wrapped object or similar.">UCharIterator.context</a> without copying or reallocating the string contents.<p>
getState() returns a state value consisting of<ul>
<li>the current UTF-8 source byte index (bits 31..1)</li><li>a flag (bit 0) that indicates whether the UChar position is in the middle of a surrogate pair (from a 4-byte UTF-8 sequence for the corresponding supplementary code point)</li></ul>
<p>
getState() cannot also encode the UTF-16 index in the state value. move(relative to limit or length), or move(relative to current) after setState(), may return UITER_UNKNOWN_INDEX.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> structure to be set for iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>UTF-8 string to iterate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of s in bytes, or -1 if NUL-terminated</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001130">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 28 17:50:03 2008 for ICU 3.8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
