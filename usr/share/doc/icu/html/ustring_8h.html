<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ICU 3.8: ustring.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ustring.h File Reference</h1>C API: Unicode string handling functions. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="utypes_8h-source.html">unicode/utypes.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="putil_8h-source.html">unicode/putil.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="uiter_8h-source.html">unicode/uiter.h</a>&quot;</code><br>

<p>
<a href="ustring_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#7fd781b068b28ee2db708090aa32df8f">U_COMPARE_CODE_POINT_ORDER</a>&nbsp;&nbsp;&nbsp;0x8000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Option bit for u_strCaseCompare, u_strcasecmp, unorm_compare, etc: Compare strings in code point order instead of code unit order.  <a href="#7fd781b068b28ee2db708090aa32df8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#df24e553d2f30e3bde48ff98d9b0e6bc">U_STRING_DECL</a>(var, cs, length)&nbsp;&nbsp;&nbsp;static const UChar var[(length)+1]=L ## cs</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unicode String literals in C.  <a href="#df24e553d2f30e3bde48ff98d9b0e6bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#f0dccce2caf6c8c657b65112f393a75b">U_STRING_INIT</a>(var, cs, length)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple declaration for <a class="el" href="ustring_8h.html#8c6202ad4ac954e225aae061b184e450" title="Titlecase a string.">u_strToTitle()</a> to avoid including <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">unicode/ubrk.h</a>.  <a href="#91403765077ce0615043a82d9adef758"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustring__ustrlen.html#gc4d8a5581fc5bde71d62ebd0a7a84ec5">u_strlen</a> (const UChar *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the length of an array of UChar.  <a href="group__ustring__ustrlen.html#gc4d8a5581fc5bde71d62ebd0a7a84ec5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#ec4a609dd5039d940e8e9524d743c88b">u_countChar32</a> (const UChar *s, int32_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count Unicode code points in the length UChar code units of the string.  <a href="#ec4a609dd5039d940e8e9524d743c88b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#abfeafb91e43b3a2c8bdd46c0743d4b2">u_strHasMoreChar32Than</a> (const UChar *s, int32_t length, int32_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the string contains more Unicode code points than a certain number.  <a href="#abfeafb91e43b3a2c8bdd46c0743d4b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#36b9bb0598b2c314c9e5fc1aaa59cbd8">u_strcat</a> (UChar *dst, const UChar *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two ustrings.  <a href="#36b9bb0598b2c314c9e5fc1aaa59cbd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#7ef9c4fbf2506fd23fae363b0b92fd11">u_strncat</a> (UChar *dst, const UChar *src, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two ustrings.  <a href="#7ef9c4fbf2506fd23fae363b0b92fd11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a">u_strstr</a> (const UChar *s, const UChar *substring)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a substring in a string.  <a href="#074dcf5f1a5b5c4088561ac5ac87883a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6">u_strFindFirst</a> (const UChar *s, int32_t length, const UChar *substring, int32_t subLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a substring in a string.  <a href="#47bdb20c28603ab39e66c9e518b5b3b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#39bb46b446b73a54204ba3016edb6737">u_strchr</a> (const UChar *s, UChar c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a BMP code point in a string.  <a href="#39bb46b446b73a54204ba3016edb6737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#789d1e49355c54ae92ad5bd579c1019b">u_strchr32</a> (const UChar *s, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a code point in a string.  <a href="#789d1e49355c54ae92ad5bd579c1019b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#55b181aa1237366b05f3b1cc158dda95">u_strrstr</a> (const UChar *s, const UChar *substring)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a substring in a string.  <a href="#55b181aa1237366b05f3b1cc158dda95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f">u_strFindLast</a> (const UChar *s, int32_t length, const UChar *substring, int32_t subLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a substring in a string.  <a href="#0304151e1130c43372d51f97d0fb2b0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#16488aa76883493fdecf3b15b0576d59">u_strrchr</a> (const UChar *s, UChar c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a BMP code point in a string.  <a href="#16488aa76883493fdecf3b15b0576d59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#2fca97af95e51306fedaf103b10fa993">u_strrchr32</a> (const UChar *s, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a code point in a string.  <a href="#2fca97af95e51306fedaf103b10fa993"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#a5c78a0cf3c46e90c96c8e5ff5abef29">u_strpbrk</a> (const UChar *string, const UChar *matchSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locates the first occurrence in the string <code>string</code> of any of the characters in the string <code>matchSet</code>.  <a href="#a5c78a0cf3c46e90c96c8e5ff5abef29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#46705ee9aa862bb21100514f96417b17">u_strcspn</a> (const UChar *string, const UChar *matchSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of consecutive characters in <code>string</code>, beginning with the first, that do not occur somewhere in <code>matchSet</code>.  <a href="#46705ee9aa862bb21100514f96417b17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#bbbb5b3b858f9e9113beaf315aa7085a">u_strspn</a> (const UChar *string, const UChar *matchSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of consecutive characters in <code>string</code>, beginning with the first, that occur somewhere in <code>matchSet</code>.  <a href="#bbbb5b3b858f9e9113beaf315aa7085a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#ccb09fb94f8b6c7b83162c3a24b698de">u_strtok_r</a> (UChar *src, const UChar *delim, UChar **saveState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The string tokenizer API allows an application to break a string into tokens.  <a href="#ccb09fb94f8b6c7b83162c3a24b698de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#bdb8af67ab5198b9db020afa9c3114b3">u_strcmp</a> (const UChar *s1, const UChar *s2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings for bitwise equality (code unit order).  <a href="#bdb8af67ab5198b9db020afa9c3114b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#a89255f4b7d6fa58e219da1abe22c733">u_strcmpCodePointOrder</a> (const UChar *s1, const UChar *s2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings in code point order.  <a href="#a89255f4b7d6fa58e219da1abe22c733"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#51fe041d3e4e408595d665c0f5f68715">u_strCompare</a> (const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> codePointOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings (binary order).  <a href="#51fe041d3e4e408595d665c0f5f68715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#ecf733c47b2a1b353947b2264f724897">u_strCompareIter</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *iter1, <a class="el" href="structUCharIterator.html">UCharIterator</a> *iter2, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> codePointOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings (binary order) as presented by <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> objects.  <a href="#ecf733c47b2a1b353947b2264f724897"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#56c7ed13d57379ff8b5f0736b0628e09">u_strCaseCompare</a> (const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, uint32_t options, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings case-insensitively using full case folding.  <a href="#56c7ed13d57379ff8b5f0736b0628e09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#6c672ffda88b342f9cc1f53a7c8d28c3">u_strncmp</a> (const UChar *ucs1, const UChar *ucs2, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two ustrings for bitwise equality.  <a href="#6c672ffda88b342f9cc1f53a7c8d28c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#d7191a125406dd8e7770dbbfb38951ee">u_strncmpCodePointOrder</a> (const UChar *s1, const UChar *s2, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings in code point order.  <a href="#d7191a125406dd8e7770dbbfb38951ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#a610819a5a35df058577f78c68ad0ab0">u_strcasecmp</a> (const UChar *s1, const UChar *s2, uint32_t options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings case-insensitively using full case folding.  <a href="#a610819a5a35df058577f78c68ad0ab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#b9cf5ce80a494a8c1501fb76ab93d4c0">u_strncasecmp</a> (const UChar *s1, const UChar *s2, int32_t n, uint32_t options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings case-insensitively using full case folding.  <a href="#b9cf5ce80a494a8c1501fb76ab93d4c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0bedcdf1bf8a8fe806ce224444a984ae">u_memcasecmp</a> (const UChar *s1, const UChar *s2, int32_t length, uint32_t options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings case-insensitively using full case folding.  <a href="#0bedcdf1bf8a8fe806ce224444a984ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#46360874cb6a798ad8a0a5e19d72a82a">u_strcpy</a> (UChar *dst, const UChar *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a ustring.  <a href="#46360874cb6a798ad8a0a5e19d72a82a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0886e9d12ac63f891f2336ea8c16c042">u_strncpy</a> (UChar *dst, const UChar *src, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a ustring.  <a href="#0886e9d12ac63f891f2336ea8c16c042"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0f2d5d46acef8e0eac711bef15e7531f">u_uastrcpy</a> (UChar *dst, const char *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a byte string encoded in the default codepage to a ustring.  <a href="#0f2d5d46acef8e0eac711bef15e7531f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#7ac7463dd6e3e36128aad288eacace8f">u_uastrncpy</a> (UChar *dst, const char *src, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a byte string encoded in the default codepage to a ustring.  <a href="#7ac7463dd6e3e36128aad288eacace8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#c80eca8339bf48f3cb650d31d4a9ef80">u_austrcpy</a> (char *dst, const UChar *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy ustring to a byte string encoded in the default codepage.  <a href="#c80eca8339bf48f3cb650d31d4a9ef80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#fe9d06488aa9de15f273f96f60635a6a">u_austrncpy</a> (char *dst, const UChar *src, int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy ustring to a byte string encoded in the default codepage.  <a href="#fe9d06488aa9de15f273f96f60635a6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#8a3bf2aff3864c0b910b15ea6e0be69e">u_memcpy</a> (UChar *dest, const UChar *src, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for memcpy(), but with UChars only.  <a href="#8a3bf2aff3864c0b910b15ea6e0be69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#98f0ccf16176d7a507102b21f2083311">u_memmove</a> (UChar *dest, const UChar *src, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for memmove(), but with UChars only.  <a href="#98f0ccf16176d7a507102b21f2083311"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#a3c77f7315557f775c4a8aeeda627382">u_memset</a> (UChar *dest, UChar c, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize <code>count</code> characters of <code>dest</code> to <code>c</code>.  <a href="#a3c77f7315557f775c4a8aeeda627382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#95643325eec27e247d28531f3c68600b">u_memcmp</a> (const UChar *buf1, const UChar *buf2, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the first <code>count</code> UChars of each buffer.  <a href="#95643325eec27e247d28531f3c68600b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#6c4db093aa0c52bb47711953cc709b1b">u_memcmpCodePointOrder</a> (const UChar *s1, const UChar *s2, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two Unicode strings in code point order.  <a href="#6c4db093aa0c52bb47711953cc709b1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#c30e88d264feb6ffd977b6a661d29f24">u_memchr</a> (const UChar *s, UChar c, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a BMP code point in a string.  <a href="#c30e88d264feb6ffd977b6a661d29f24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#14f1a66d758f90167c1bf91aee634b71">u_memchr32</a> (const UChar *s, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> c, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first occurrence of a code point in a string.  <a href="#14f1a66d758f90167c1bf91aee634b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#f5002dc5e89378549c68313968790ed7">u_memrchr</a> (const UChar *s, UChar c, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a BMP code point in a string.  <a href="#f5002dc5e89378549c68313968790ed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#a012a35978c2e4a5aa4073d6c3edf7e5">u_memrchr32</a> (const UChar *s, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> c, int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last occurrence of a code point in a string.  <a href="#a012a35978c2e4a5aa4073d6c3edf7e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#7aad56a2a6f7cbe3b2fb802a218d239b">u_unescape</a> (const char *src, UChar *dest, int32_t destCapacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unescape a string of characters and write the resulting Unicode characters to the destination buffer.  <a href="#7aad56a2a6f7cbe3b2fb802a218d239b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U_CDECL_BEGIN typedef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#ba21ae6407ec5fc560be58bbc35af6a2">UChar</a> (U_CALLCONV *UNESCAPE_CHAR_AT)(int32_t offset</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for <a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt()</a> that returns a character of the source text given an offset and a context pointer.  <a href="#ba21ae6407ec5fc560be58bbc35af6a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U_CDECL_END <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0">u_unescapeAt</a> (UNESCAPE_CHAR_AT charAt, int32_t *offset, int32_t length, void *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unescape a single sequence.  <a href="#82a0eed3cd4ec580c996301c0b1a73b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#14740e3b734ffa82205d4762fcacb5e1">u_strToUpper</a> (UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uppercase the characters in a string.  <a href="#14740e3b734ffa82205d4762fcacb5e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#e3ed589f5ce0d550c228ee69bfed58fb">u_strToLower</a> (UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowercase the characters in a string.  <a href="#e3ed589f5ce0d550c228ee69bfed58fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#8c6202ad4ac954e225aae061b184e450">u_strToTitle</a> (UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *titleIter, const char *locale, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Titlecase a string.  <a href="#8c6202ad4ac954e225aae061b184e450"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#b6709b5a5c1606cf0d3ea24934d9acce">u_strFoldCase</a> (UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, uint32_t options, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Case-fold the characters in a string.  <a href="#b6709b5a5c1606cf0d3ea24934d9acce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">wchar_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#184562a078b0a961d9281b0c29bb5406">u_strToWCS</a> (wchar_t *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UChars to wchar_t units.  <a href="#184562a078b0a961d9281b0c29bb5406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#d7f574ab350d889fce6e44514807728d">u_strFromWCS</a> (UChar *dest, int32_t destCapacity, int32_t *pDestLength, const wchar_t *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of wchar_t units to UChars.  <a href="#d7f574ab350d889fce6e44514807728d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0ca7af2cf47b116454eed92331594afa">u_strToUTF8</a> (char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UChars (UTF-16) to UTF-8 bytes.  <a href="#0ca7af2cf47b116454eed92331594afa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4">u_strFromUTF8</a> (UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UTF-8 bytes to UChars (UTF-16).  <a href="#5f9ff224b11166a106d1b3ac26454cd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#7a79e37a3b1a261a9326029d2a1b1b80">u_strToUTF8WithSub</a> (char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> subchar, int32_t *pNumSubstitutions, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UChars (UTF-16) to UTF-8 bytes.  <a href="#7a79e37a3b1a261a9326029d2a1b1b80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0e9b7cd493c351804322ad1805fbe775">u_strFromUTF8WithSub</a> (UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> subchar, int32_t *pNumSubstitutions, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UTF-8 bytes to UChars (UTF-16).  <a href="#0e9b7cd493c351804322ad1805fbe775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#e5d278594ac005f683bf35e8e4373130">u_strFromUTF8Lenient</a> (UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UTF-8 bytes to UChars (UTF-16).  <a href="#e5d278594ac005f683bf35e8e4373130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#471e6e4857f06b262ceac485b7ffcae4">u_strToUTF32</a> (<a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UChars (UTF-16) to UTF32 units.  <a href="#471e6e4857f06b262ceac485b7ffcae4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustring_8h.html#0b6154c1f288ec9a4d25fb0678cd90a0">u_strFromUTF32</a> (UChar *dest, int32_t destCapacity, int32_t *pDestLength, const <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a sequence of UTF32 units to UChars (UTF-16).  <a href="#0b6154c1f288ec9a4d25fb0678cd90a0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74d84f88a14c68a4e733d56943bf886a"></a><!-- doxytag: member="ustring.h::context" ref="74d84f88a14c68a4e733d56943bf886a" args="" -->
U_CDECL_BEGIN typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>context</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
C API: Unicode string handling functions. 
<p>
These C API functions provide general Unicode string handling.<p>
Some functions are equivalent in name, signature, and behavior to the ANSI C &lt;string.h&gt; functions. (For example, they do not check for bad arguments like NULL string pointers.) In some cases, only the thread-safe variant of such a function is implemented here (see <a class="el" href="ustring_8h.html#ccb09fb94f8b6c7b83162c3a24b698de" title="The string tokenizer API allows an application to break a string into tokens.">u_strtok_r()</a>).<p>
Other functions provide more Unicode-specific functionality like locale-specific upper/lower-casing and string comparison in code point order.<p>
ICU uses 16-bit Unicode (UTF-16) in the form of arrays of UChar code units. UTF-16 encodes each Unicode code point with either one or two UChar code units. (This is the default form of Unicode, and a forward-compatible extension of the original, fixed-width form that was known as UCS-2. UTF-16 superseded UCS-2 with Unicode 2.0 in 1996.)<p>
Some APIs accept a 32-bit UChar32 value for a single code point.<p>
ICU also handles 16-bit Unicode text with unpaired surrogates. Such text is not well-formed UTF-16. Code-point-related functions treat unpaired surrogates as surrogate code points, i.e., as separate units.<p>
Although UTF-16 is a variable-width encoding form (like some legacy multi-byte encodings), it is much more efficient even for random access because the code unit values for single-unit characters vs. lead units vs. trail units are completely disjoint. This means that it is easy to determine character (code point) boundaries from random offsets in the string.<p>
Unicode (UTF-16) string processing is optimized for the single-unit case. Although it is important to support supplementary characters (which use pairs of lead/trail code units called "surrogates"), their occurrence is rare. Almost all characters in modern use require only a single UChar code unit (i.e., their code point values are &lt;=0xffff).<p>
For more details see the User Guide Strings chapter (<a href="http://icu-project.org/userguide/strings.html">http://icu-project.org/userguide/strings.html</a>). For a discussion of the handling of unpaired surrogates see also Jitterbug 2145 and its icu mailing list proposal on 2002-sep-18. 
<p>Definition in file <a class="el" href="ustring_8h-source.html">ustring.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="7fd781b068b28ee2db708090aa32df8f"></a><!-- doxytag: member="ustring.h::U_COMPARE_CODE_POINT_ORDER" ref="7fd781b068b28ee2db708090aa32df8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_COMPARE_CODE_POINT_ORDER&nbsp;&nbsp;&nbsp;0x8000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Option bit for u_strCaseCompare, u_strcasecmp, unorm_compare, etc: Compare strings in code point order instead of code unit order. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001748">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Definition at line <a class="el" href="ustring_8h-source.html#l00499">499</a> of file <a class="el" href="ustring_8h-source.html">ustring.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="df24e553d2f30e3bde48ff98d9b0e6bc"></a><!-- doxytag: member="ustring.h::U_STRING_DECL" ref="df24e553d2f30e3bde48ff98d9b0e6bc" args="(var, cs, length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_STRING_DECL          </td>
          <td>(</td>
          <td class="paramtype">var,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">length&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;static const UChar var[(length)+1]=L ## cs</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unicode String literals in C. 
<p>
We need one macro to declare a variable for the string and to statically preinitialize it if possible, and a second macro to dynamically intialize such a string variable if necessary.<p>
The macros are defined for maximum performance. They work only for strings that contain "invariant characters", i.e., only latin letters, digits, and some punctuation. See <a class="el" href="utypes_8h.html" title="Basic definitions for ICU, for both C and C++ APIs.">utypes.h</a> for details.<p>
A pair of macros for a single string must be used with the same parameters. The string parameter must be a C string literal. The length of the string, not including the terminating <code>NUL</code>, must be specified as a constant. The U_STRING_DECL macro should be invoked exactly once for one such string variable before it is used.<p>
Usage: <pre>
    U_STRING_DECL(ustringVar1, "Quick-Fox 2", 11);
    U_STRING_DECL(ustringVar2, "jumps 5%", 8);
    static UBool didInit=FALSE;</pre><p>
<pre>    int32_t function() {
        if(!didInit) {
            U_STRING_INIT(ustringVar1, "Quick-Fox 2", 11);
            U_STRING_INIT(ustringVar2, "jumps 5%", 8);
            didInit=TRUE;
        }
        return u_strcmp(ustringVar1, ustringVar2);
    }
 </pre> <dl compact><dt><b><a class="el" href="stable.html#_stable001770">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ustring_8h-source.html#l00926">926</a> of file <a class="el" href="ustring_8h-source.html">ustring.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f0dccce2caf6c8c657b65112f393a75b"></a><!-- doxytag: member="ustring.h::U_STRING_INIT" ref="f0dccce2caf6c8c657b65112f393a75b" args="(var, cs, length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_STRING_INIT          </td>
          <td>(</td>
          <td class="paramtype">var,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">length&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001771">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ustring_8h-source.html#l00928">928</a> of file <a class="el" href="ustring_8h-source.html">ustring.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="91403765077ce0615043a82d9adef758"></a><!-- doxytag: member="ustring.h::UBreakIterator" ref="91403765077ce0615043a82d9adef758" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple declaration for <a class="el" href="ustring_8h.html#8c6202ad4ac954e225aae061b184e450" title="Titlecase a string.">u_strToTitle()</a> to avoid including <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">unicode/ubrk.h</a>. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001726">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

<p>Definition at line <a class="el" href="ustring_8h-source.html#l00026">26</a> of file <a class="el" href="ustring_8h-source.html">ustring.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c80eca8339bf48f3cb650d31d4a9ef80"></a><!-- doxytag: member="ustring.h::u_austrcpy" ref="c80eca8339bf48f3cb650d31d4a9ef80" args="(char *dst, const UChar *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* u_austrcpy           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy ustring to a byte string encoded in the default codepage. 
<p>
Adds a null terminator. Performs a UChar to host byte conversion<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001759">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe9d06488aa9de15f273f96f60635a6a"></a><!-- doxytag: member="ustring.h::u_austrncpy" ref="fe9d06488aa9de15f273f96f60635a6a" args="(char *dst, const UChar *src, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* u_austrncpy           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy ustring to a byte string encoded in the default codepage. 
<p>
Copies at most <code>n</code> characters. The result will be null terminated if the length of <code>src</code> is less than <code>n</code>. Performs a UChar to host byte conversion<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to copy. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001760">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec4a609dd5039d940e8e9524d743c88b"></a><!-- doxytag: member="ustring.h::u_countChar32" ref="ec4a609dd5039d940e8e9524d743c88b" args="(const UChar *s, int32_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_countChar32           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Count Unicode code points in the length UChar code units of the string. 
<p>
A code point may occupy either one or two UChar code units. Counting code points involves reading all code units.<p>
This functions is basically the inverse of the <a class="el" href="utf16_8h.html#d70d5a679bd03c63131219c7808d9de9" title="Advance the string offset from one code point boundary to the n-th next one, i.e...">U16_FWD_N()</a> macro (see <a class="el" href="utf_8h.html" title="C API: Code point macros.">utf.h</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The input string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of UChar code units to be checked, or -1 to count all code points before the first NUL (U+0000). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of code points in the specified code units. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001728">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0bedcdf1bf8a8fe806ce224444a984ae"></a><!-- doxytag: member="ustring.h::u_memcasecmp" ref="0bedcdf1bf8a8fe806ce224444a984ae" args="(const UChar *s1, const UChar *s2, int32_t length, uint32_t options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_memcasecmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings case-insensitively using full case folding. 
<p>
This is equivalent to u_strcmp(u_strFoldCase(s1, n, options), u_strFoldCase(s2, n, options)).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of characters in each string to case-fold and then compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bit set of options:<ul>
<li>U_FOLD_CASE_DEFAULT or 0 is used for default options: Comparison in code unit order with default case folding.</li></ul>
</td></tr>
  </table>
</dl>
<ul>
<li>U_COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order (see u_strCompare for details).</li></ul>
<p>
<ul>
<li>U_FOLD_CASE_EXCLUDE_SPECIAL_I</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative, zero, or positive integer indicating the comparison result. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001754">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c30e88d264feb6ffd977b6a661d29f24"></a><!-- doxytag: member="ustring.h::u_memchr" ref="c30e88d264feb6ffd977b6a661d29f24" args="(const UChar *s, UChar c, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memchr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a BMP code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (contains <code>count</code> UChars). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The BMP code point to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001766">Stable:</a></b></dt><dd>ICU 2.0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#39bb46b446b73a54204ba3016edb6737" title="Find the first occurrence of a BMP code point in a string.">u_strchr</a> <p>
<a class="el" href="ustring_8h.html#14f1a66d758f90167c1bf91aee634b71" title="Find the first occurrence of a code point in a string.">u_memchr32</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="14f1a66d758f90167c1bf91aee634b71"></a><!-- doxytag: member="ustring.h::u_memchr32" ref="14f1a66d758f90167c1bf91aee634b71" args="(const UChar *s, UChar32 c, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memchr32           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (contains <code>count</code> UChars). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The code point to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001767">Stable:</a></b></dt><dd>ICU 2.0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#789d1e49355c54ae92ad5bd579c1019b" title="Find the first occurrence of a code point in a string.">u_strchr32</a> <p>
<a class="el" href="ustring_8h.html#c30e88d264feb6ffd977b6a661d29f24" title="Find the first occurrence of a BMP code point in a string.">u_memchr</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="95643325eec27e247d28531f3c68600b"></a><!-- doxytag: member="ustring.h::u_memcmp" ref="95643325eec27e247d28531f3c68600b" args="(const UChar *buf1, const UChar *buf2, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_memcmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare the first <code>count</code> UChars of each buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>The first string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>The second string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of UChars to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>When buf1 &lt; buf2, a negative number is returned. When buf1 == buf2, 0 is returned. When buf1 &gt; buf2, a positive number is returned. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001764">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c4db093aa0c52bb47711953cc709b1b"></a><!-- doxytag: member="ustring.h::u_memcmpCodePointOrder" ref="6c4db093aa0c52bb47711953cc709b1b" args="(const UChar *s1, const UChar *s2, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_memcmpCodePointOrder           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings in code point order. 
<p>
This is different in UTF-16 from <a class="el" href="ustring_8h.html#95643325eec27e247d28531f3c68600b" title="Compare the first count UChars of each buffer.">u_memcmp()</a> if supplementary characters are present. For details, see <a class="el" href="ustring_8h.html#51fe041d3e4e408595d665c0f5f68715" title="Compare two Unicode strings (binary order).">u_strCompare()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a negative/zero/positive integer corresponding to whether the first string is less than/equal to/greater than the second one in code point order </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001765">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a3bf2aff3864c0b910b15ea6e0be69e"></a><!-- doxytag: member="ustring.h::u_memcpy" ref="8a3bf2aff3864c0b910b15ea6e0be69e" args="(UChar *dest, const UChar *src, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memcpy           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synonym for memcpy(), but with UChars only. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to copy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dest</code> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001761">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="98f0ccf16176d7a507102b21f2083311"></a><!-- doxytag: member="ustring.h::u_memmove" ref="98f0ccf16176d7a507102b21f2083311" args="(UChar *dest, const UChar *src, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memmove           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synonym for memmove(), but with UChars only. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to move </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dest</code> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001762">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5002dc5e89378549c68313968790ed7"></a><!-- doxytag: member="ustring.h::u_memrchr" ref="f5002dc5e89378549c68313968790ed7" args="(const UChar *s, UChar c, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memrchr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a BMP code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (contains <code>count</code> UChars). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The BMP code point to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001768">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#16488aa76883493fdecf3b15b0576d59" title="Find the last occurrence of a BMP code point in a string.">u_strrchr</a> <p>
<a class="el" href="ustring_8h.html#a012a35978c2e4a5aa4073d6c3edf7e5" title="Find the last occurrence of a code point in a string.">u_memrchr32</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a012a35978c2e4a5aa4073d6c3edf7e5"></a><!-- doxytag: member="ustring.h::u_memrchr32" ref="a012a35978c2e4a5aa4073d6c3edf7e5" args="(const UChar *s, UChar32 c, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memrchr32           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (contains <code>count</code> UChars). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The code point to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of the string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001769">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#2fca97af95e51306fedaf103b10fa993" title="Find the last occurrence of a code point in a string.">u_strrchr32</a> <p>
<a class="el" href="ustring_8h.html#f5002dc5e89378549c68313968790ed7" title="Find the last occurrence of a BMP code point in a string.">u_memrchr</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3c77f7315557f775c4a8aeeda627382"></a><!-- doxytag: member="ustring.h::u_memset" ref="a3c77f7315557f775c4a8aeeda627382" args="(UChar *dest, UChar c, int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_memset           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize <code>count</code> characters of <code>dest</code> to <code>c</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The character to initialize the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters to set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dest</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001763">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a610819a5a35df058577f78c68ad0ab0"></a><!-- doxytag: member="ustring.h::u_strcasecmp" ref="a610819a5a35df058577f78c68ad0ab0" args="(const UChar *s1, const UChar *s2, uint32_t options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strcasecmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings case-insensitively using full case folding. 
<p>
This is equivalent to u_strcmp(u_strFoldCase(s1, options), u_strFoldCase(s2, options)).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bit set of options:<ul>
<li>U_FOLD_CASE_DEFAULT or 0 is used for default options: Comparison in code unit order with default case folding.</li></ul>
</td></tr>
  </table>
</dl>
<ul>
<li>U_COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order (see u_strCompare for details).</li></ul>
<p>
<ul>
<li>U_FOLD_CASE_EXCLUDE_SPECIAL_I</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative, zero, or positive integer indicating the comparison result. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001752">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="56c7ed13d57379ff8b5f0736b0628e09"></a><!-- doxytag: member="ustring.h::u_strCaseCompare" ref="56c7ed13d57379ff8b5f0736b0628e09" args="(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, uint32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strCaseCompare           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings case-insensitively using full case folding. 
<p>
This is equivalent to u_strCompare(u_strFoldCase(s1, options), u_strFoldCase(s2, options), (options&amp;U_COMPARE_CODE_POINT_ORDER)!=0).<p>
The comparison can be done in UTF-16 code unit order or in code point order. They differ only when comparing supplementary code points (U+10000..U+10ffff) to BMP code points near the end of the BMP (i.e., U+e000..U+ffff). In code unit order, high BMP code points sort after supplementary code points because they are stored as pairs of surrogates which are at U+d800..U+dfff.<p>
This functions works with strings of different explicitly specified lengths unlike the ANSI C-like <a class="el" href="ustring_8h.html#bdb8af67ab5198b9db020afa9c3114b3" title="Compare two Unicode strings for bitwise equality (code unit order).">u_strcmp()</a> and <a class="el" href="ustring_8h.html#95643325eec27e247d28531f3c68600b" title="Compare the first count UChars of each buffer.">u_memcmp()</a> etc. NUL-terminated strings are possible with length arguments of -1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>First source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length1</em>&nbsp;</td><td>Length of first source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>Second source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length2</em>&nbsp;</td><td>Length of second source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bit set of options:<ul>
<li>U_FOLD_CASE_DEFAULT or 0 is used for default options: Comparison in code unit order with default case folding.</li></ul>
</td></tr>
  </table>
</dl>
<ul>
<li>U_COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order (see u_strCompare for details).</li></ul>
<p>
<ul>
<li>U_FOLD_CASE_EXCLUDE_SPECIAL_I</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt;0 or 0 or &gt;0 as usual for string comparisons</dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001749">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="36b9bb0598b2c314c9e5fc1aaa59cbd8"></a><!-- doxytag: member="ustring.h::u_strcat" ref="36b9bb0598b2c314c9e5fc1aaa59cbd8" args="(UChar *dst, const UChar *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strcat           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two ustrings. 
<p>
Appends a copy of <code>src</code>, including the null terminator, to <code>dst</code>. The initial copied character from <code>src</code> overwrites the null terminator in <code>dst</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001730">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="39bb46b446b73a54204ba3016edb6737"></a><!-- doxytag: member="ustring.h::u_strchr" ref="39bb46b446b73a54204ba3016edb6737" args="(const UChar *s, UChar c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strchr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a BMP code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The BMP code point to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001734">Stable:</a></b></dt><dd>ICU 2.0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#789d1e49355c54ae92ad5bd579c1019b" title="Find the first occurrence of a code point in a string.">u_strchr32</a> <p>
<a class="el" href="ustring_8h.html#c30e88d264feb6ffd977b6a661d29f24" title="Find the first occurrence of a BMP code point in a string.">u_memchr</a> <p>
<a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a" title="Find the first occurrence of a substring in a string.">u_strstr</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="789d1e49355c54ae92ad5bd579c1019b"></a><!-- doxytag: member="ustring.h::u_strchr32" ref="789d1e49355c54ae92ad5bd579c1019b" args="(const UChar *s, UChar32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strchr32           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The code point to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001735">Stable:</a></b></dt><dd>ICU 2.0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#39bb46b446b73a54204ba3016edb6737" title="Find the first occurrence of a BMP code point in a string.">u_strchr</a> <p>
<a class="el" href="ustring_8h.html#14f1a66d758f90167c1bf91aee634b71" title="Find the first occurrence of a code point in a string.">u_memchr32</a> <p>
<a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a" title="Find the first occurrence of a substring in a string.">u_strstr</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bdb8af67ab5198b9db020afa9c3114b3"></a><!-- doxytag: member="ustring.h::u_strcmp" ref="bdb8af67ab5198b9db020afa9c3114b3" args="(const UChar *s1, const UChar *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strcmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings for bitwise equality (code unit order). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if <code>s1</code> and <code>s2</code> are bitwise equal; a negative value if <code>s1</code> is bitwise less than <code>s2,</code>; a positive value if <code>s1</code> is bitwise greater than <code>s2</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001744">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a89255f4b7d6fa58e219da1abe22c733"></a><!-- doxytag: member="ustring.h::u_strcmpCodePointOrder" ref="a89255f4b7d6fa58e219da1abe22c733" args="(const UChar *s1, const UChar *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strcmpCodePointOrder           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings in code point order. 
<p>
See u_strCompare for details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a negative/zero/positive integer corresponding to whether the first string is less than/equal to/greater than the second one in code point order </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001745">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="51fe041d3e4e408595d665c0f5f68715"></a><!-- doxytag: member="ustring.h::u_strCompare" ref="51fe041d3e4e408595d665c0f5f68715" args="(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, UBool codePointOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strCompare           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>codePointOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings (binary order). 
<p>
The comparison can be done in code unit order or in code point order. They differ only in UTF-16 when comparing supplementary code points (U+10000..U+10ffff) to BMP code points near the end of the BMP (i.e., U+e000..U+ffff). In code unit order, high BMP code points sort after supplementary code points because they are stored as pairs of surrogates which are at U+d800..U+dfff.<p>
This functions works with strings of different explicitly specified lengths unlike the ANSI C-like <a class="el" href="ustring_8h.html#bdb8af67ab5198b9db020afa9c3114b3" title="Compare two Unicode strings for bitwise equality (code unit order).">u_strcmp()</a> and <a class="el" href="ustring_8h.html#95643325eec27e247d28531f3c68600b" title="Compare the first count UChars of each buffer.">u_memcmp()</a> etc. NUL-terminated strings are possible with length arguments of -1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>First source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length1</em>&nbsp;</td><td>Length of first source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>Second source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length2</em>&nbsp;</td><td>Length of second source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codePointOrder</em>&nbsp;</td><td>Choose between code unit order (FALSE) and code point order (TRUE).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt;0 or 0 or &gt;0 as usual for string comparisons</dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001746">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecf733c47b2a1b353947b2264f724897"></a><!-- doxytag: member="ustring.h::u_strCompareIter" ref="ecf733c47b2a1b353947b2264f724897" args="(UCharIterator *iter1, UCharIterator *iter2, UBool codePointOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strCompareIter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>codePointOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings (binary order) as presented by <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> objects. 
<p>
Works otherwise just like <a class="el" href="ustring_8h.html#51fe041d3e4e408595d665c0f5f68715" title="Compare two Unicode strings (binary order).">u_strCompare()</a>.<p>
Both iterators are reset to their start positions. When the function returns, it is undefined where the iterators have stopped.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter1</em>&nbsp;</td><td>First source string iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter2</em>&nbsp;</td><td>Second source string iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codePointOrder</em>&nbsp;</td><td>Choose between code unit order (FALSE) and code point order (TRUE).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt;0 or 0 or &gt;0 as usual for string comparisons</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#51fe041d3e4e408595d665c0f5f68715" title="Compare two Unicode strings (binary order).">u_strCompare</a></dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001747">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="46360874cb6a798ad8a0a5e19d72a82a"></a><!-- doxytag: member="ustring.h::u_strcpy" ref="46360874cb6a798ad8a0a5e19d72a82a" args="(UChar *dst, const UChar *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strcpy           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a ustring. 
<p>
Adds a null terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001755">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="46705ee9aa862bb21100514f96417b17"></a><!-- doxytag: member="ustring.h::u_strcspn" ref="46705ee9aa862bb21100514f96417b17" args="(const UChar *string, const UChar *matchSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strcspn           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>matchSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of consecutive characters in <code>string</code>, beginning with the first, that do not occur somewhere in <code>matchSet</code>. 
<p>
Works just like C's strcspn but with Unicode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string in which to search, NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchSet</em>&nbsp;</td><td>A NUL-terminated string defining a set of code points for which to search in the text string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of initial characters in <code>string</code> that do not occur in <code>matchSet</code>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#bbbb5b3b858f9e9113beaf315aa7085a" title="Returns the number of consecutive characters in string, beginning with the first...">u_strspn</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001741">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="47bdb20c28603ab39e66c9e518b5b3b6"></a><!-- doxytag: member="ustring.h::u_strFindFirst" ref="47bdb20c28603ab39e66c9e518b5b3b6" args="(const UChar *s, int32_t length, const UChar *substring, int32_t subLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFindFirst           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>substring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>subLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a substring in a string. 
<p>
The substring is found at code point boundaries. That means that if the substring begins with a trail surrogate or ends with a lead surrogate, then it is found only if these surrogates stand alone in the text. Otherwise, the substring edge units would be matched against halves of surrogate pairs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of s (number of UChars), or -1 if it is NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>substring</em>&nbsp;</td><td>The substring to find (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subLength</em>&nbsp;</td><td>The length of substring (number of UChars), or -1 if it is NUL-terminated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>substring</code> in <code>s</code>, or <code>s</code> itself if the <code>substring</code> is empty, or <code>NULL</code> if <code>substring</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001733">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a" title="Find the first occurrence of a substring in a string.">u_strstr</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0304151e1130c43372d51f97d0fb2b0f"></a><!-- doxytag: member="ustring.h::u_strFindLast" ref="0304151e1130c43372d51f97d0fb2b0f" args="(const UChar *s, int32_t length, const UChar *substring, int32_t subLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFindLast           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>substring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>subLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a substring in a string. 
<p>
The substring is found at code point boundaries. That means that if the substring begins with a trail surrogate or ends with a lead surrogate, then it is found only if these surrogates stand alone in the text. Otherwise, the substring edge units would be matched against halves of surrogate pairs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of s (number of UChars), or -1 if it is NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>substring</em>&nbsp;</td><td>The substring to find (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subLength</em>&nbsp;</td><td>The length of substring (number of UChars), or -1 if it is NUL-terminated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>substring</code> in <code>s</code>, or <code>s</code> itself if the <code>substring</code> is empty, or <code>NULL</code> if <code>substring</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001737">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a" title="Find the first occurrence of a substring in a string.">u_strstr</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6709b5a5c1606cf0d3ea24934d9acce"></a><!-- doxytag: member="ustring.h::u_strFoldCase" ref="b6709b5a5c1606cf0d3ea24934d9acce" args="(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, uint32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strFoldCase           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Case-fold the characters in a string. 
<p>
Case-folding is locale-independent and not context-sensitive, but there is an option for whether to include or exclude mappings for dotted I and dotless i that are marked with 'I' in CaseFolding.txt. The result may be longer or shorter than the original. The source string and the destination buffer are allowed to overlap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Either U_FOLD_CASE_DEFAULT or U_FOLD_CASE_EXCLUDE_SPECIAL_I </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of the result string. It may be greater than destCapacity. In that case, only some of the result was written to the destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001778">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b6154c1f288ec9a4d25fb0678cd90a0"></a><!-- doxytag: member="ustring.h::u_strFromUTF32" ref="0b6154c1f288ec9a4d25fb0678cd90a0" args="(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const UChar32 *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFromUTF32           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UTF32 units to UChars (UTF-16). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001787">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f9ff224b11166a106d1b3ac26454cd4"></a><!-- doxytag: member="ustring.h::u_strFromUTF8" ref="5f9ff224b11166a106d1b3ac26454cd4" args="(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFromUTF8           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UTF-8 bytes to UChars (UTF-16). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001782">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#0e9b7cd493c351804322ad1805fbe775" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8WithSub</a> <p>
<a class="el" href="ustring_8h.html#e5d278594ac005f683bf35e8e4373130" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8Lenient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5d278594ac005f683bf35e8e4373130"></a><!-- doxytag: member="ustring.h::u_strFromUTF8Lenient" ref="e5d278594ac005f683bf35e8e4373130" args="(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFromUTF8Lenient           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UTF-8 bytes to UChars (UTF-16). 
<p>
Same as <a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8()</a> except that this function is designed to be very fast, which it achieves by being lenient about malformed UTF-8 sequences. This function is intended for use in environments where UTF-8 text is expected to be well-formed.<p>
Its semantics are:<ul>
<li>Well-formed UTF-8 text is correctly converted to well-formed UTF-16 text.</li><li>The function will not read beyond the input string, nor write beyond the destCapacity.</li><li>Malformed UTF-8 results in "garbage" 16-bit Unicode strings which may not be well-formed UTF-16. The function will resynchronize to valid code point boundaries within a small number of code points after an illegal sequence.</li><li>Non-shortest forms are not detected and will result in "spoofing" output.</li></ul>
<p>
For further performance improvement, if srcLength is given (&gt;=0), then it must be destCapacity&gt;=srcLength.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). Unlike for other ICU functions, if srcLength&gt;=0 then it must be destCapacity&gt;=srcLength. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. Unlike for other ICU functions, if srcLength&gt;=0 but destCapacity&lt;srcLength, then *pDestLength will be set to srcLength (and U_BUFFER_OVERFLOW_ERROR will be set) regardless of the actual result length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Pointer to a standard ICU error code. Its input value must pass the <a class="el" href="utypes_8h.html#527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS()</a> test, or else the function returns immediately. Check for <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a> on output or use with function chaining. (See User Guide for details.) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8</a> <p>
<a class="el" href="ustring_8h.html#0e9b7cd493c351804322ad1805fbe775" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8WithSub</a> <p>
<a class="el" href="ustring_8h.html#7a79e37a3b1a261a9326029d2a1b1b80" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8WithSub</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001785">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e9b7cd493c351804322ad1805fbe775"></a><!-- doxytag: member="ustring.h::u_strFromUTF8WithSub" ref="0e9b7cd493c351804322ad1805fbe775" args="(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFromUTF8WithSub           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>subchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pNumSubstitutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UTF-8 bytes to UChars (UTF-16). 
<p>
Same as <a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8()</a> except for the additional subchar which is output for illegal input sequences, instead of stopping with the U_INVALID_CHAR_FOUND error code. With subchar==U_SENTINEL, this function behaves exactly like <a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subchar</em>&nbsp;</td><td>The substitution character to use in place of an illegal input sequence, or U_SENTINEL if the function is to return with U_INVALID_CHAR_FOUND instead. A substitution character can be any valid Unicode code point (up to U+10FFFF) except for surrogate code points (U+D800..U+DFFF). The recommended value is U+FFFD "REPLACEMENT CHARACTER". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNumSubstitutions</em>&nbsp;</td><td>Output parameter receiving the number of substitutions if subchar&gt;=0. Set to 0 if no substitutions occur or subchar&lt;0. pNumSubstitutions can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Pointer to a standard ICU error code. Its input value must pass the <a class="el" href="utypes_8h.html#527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS()</a> test, or else the function returns immediately. Check for <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a> on output or use with function chaining. (See User Guide for details.) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8</a> <p>
<a class="el" href="ustring_8h.html#e5d278594ac005f683bf35e8e4373130" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8Lenient</a> <p>
<a class="el" href="ustring_8h.html#7a79e37a3b1a261a9326029d2a1b1b80" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8WithSub</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001784">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7f574ab350d889fce6e44514807728d"></a><!-- doxytag: member="ustring.h::u_strFromWCS" ref="d7f574ab350d889fce6e44514807728d" args="(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const wchar_t *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strFromWCS           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of wchar_t units to UChars. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001780">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="abfeafb91e43b3a2c8bdd46c0743d4b2"></a><!-- doxytag: member="ustring.h::u_strHasMoreChar32Than" ref="abfeafb91e43b3a2c8bdd46c0743d4b2" args="(const UChar *s, int32_t length, int32_t number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> u_strHasMoreChar32Than           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the string contains more Unicode code points than a certain number. 
<p>
This is more efficient than counting all code points in the entire string and comparing that number with a threshold. This function may not need to scan the string at all if the length is known (not -1 for NUL-termination) and falls within a certain range, and never needs to count more than 'number+1' code points. Logically equivalent to (u_countChar32(s, length)&gt;number). A Unicode code point may occupy either one or two UChar code units.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The input string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the string, or -1 if it is NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>The number of code points in the string is compared against the 'number' parameter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean value for whether the string contains more Unicode code points than 'number'. Same as (u_countChar32(s, length)&gt;number). </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001729">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9cf5ce80a494a8c1501fb76ab93d4c0"></a><!-- doxytag: member="ustring.h::u_strncasecmp" ref="b9cf5ce80a494a8c1501fb76ab93d4c0" args="(const UChar *s1, const UChar *s2, int32_t n, uint32_t options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strncasecmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings case-insensitively using full case folding. 
<p>
This is equivalent to u_strcmp(u_strFoldCase(s1, at most n, options), u_strFoldCase(s2, at most n, options)).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters each string to case-fold and then compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bit set of options:<ul>
<li>U_FOLD_CASE_DEFAULT or 0 is used for default options: Comparison in code unit order with default case folding.</li></ul>
</td></tr>
  </table>
</dl>
<ul>
<li>U_COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order (see u_strCompare for details).</li></ul>
<p>
<ul>
<li>U_FOLD_CASE_EXCLUDE_SPECIAL_I</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative, zero, or positive integer indicating the comparison result. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001753">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ef9c4fbf2506fd23fae363b0b92fd11"></a><!-- doxytag: member="ustring.h::u_strncat" ref="7ef9c4fbf2506fd23fae363b0b92fd11" args="(UChar *dst, const UChar *src, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strncat           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two ustrings. 
<p>
Appends at most <code>n</code> characters from <code>src</code> to <code>dst</code>. Adds a terminating NUL. If src is too long, then only <code>n-1</code> characters will be copied before the terminating NUL. If <code>n&lt;=0</code> then dst is not modified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001731">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c672ffda88b342f9cc1f53a7c8d28c3"></a><!-- doxytag: member="ustring.h::u_strncmp" ref="6c672ffda88b342f9cc1f53a7c8d28c3" args="(const UChar *ucs1, const UChar *ucs2, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strncmp           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>ucs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>ucs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two ustrings for bitwise equality. 
<p>
Compares at most <code>n</code> characters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ucs1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ucs2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if <code>s1</code> and <code>s2</code> are bitwise equal; a negative value if <code>s1</code> is bitwise less than <code>s2</code>; a positive value if <code>s1</code> is bitwise greater than <code>s2</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001750">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7191a125406dd8e7770dbbfb38951ee"></a><!-- doxytag: member="ustring.h::u_strncmpCodePointOrder" ref="d7191a125406dd8e7770dbbfb38951ee" args="(const UChar *s1, const UChar *s2, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strncmpCodePointOrder           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two Unicode strings in code point order. 
<p>
This is different in UTF-16 from <a class="el" href="ustring_8h.html#6c672ffda88b342f9cc1f53a7c8d28c3" title="Compare two ustrings for bitwise equality.">u_strncmp()</a> if supplementary characters are present. For details, see <a class="el" href="ustring_8h.html#51fe041d3e4e408595d665c0f5f68715" title="Compare two Unicode strings (binary order).">u_strCompare()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a negative/zero/positive integer corresponding to whether the first string is less than/equal to/greater than the second one in code point order </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001751">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0886e9d12ac63f891f2336ea8c16c042"></a><!-- doxytag: member="ustring.h::u_strncpy" ref="0886e9d12ac63f891f2336ea8c16c042" args="(UChar *dst, const UChar *src, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strncpy           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a ustring. 
<p>
Copies at most <code>n</code> characters. The result will be null terminated if the length of <code>src</code> is less than <code>n</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to copy. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001756">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5c78a0cf3c46e90c96c8e5ff5abef29"></a><!-- doxytag: member="ustring.h::u_strpbrk" ref="a5c78a0cf3c46e90c96c8e5ff5abef29" args="(const UChar *string, const UChar *matchSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strpbrk           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>matchSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locates the first occurrence in the string <code>string</code> of any of the characters in the string <code>matchSet</code>. 
<p>
Works just like C's strpbrk but with Unicode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string in which to search, NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchSet</em>&nbsp;</td><td>A NUL-terminated string defining a set of code points for which to search in the text string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the character in <code>string</code> that matches one of the characters in <code>matchSet</code>, or NULL if no such character is found. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001740">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="16488aa76883493fdecf3b15b0576d59"></a><!-- doxytag: member="ustring.h::u_strrchr" ref="16488aa76883493fdecf3b15b0576d59" args="(const UChar *s, UChar c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strrchr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a BMP code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The BMP code point to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001738">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#2fca97af95e51306fedaf103b10fa993" title="Find the last occurrence of a code point in a string.">u_strrchr32</a> <p>
<a class="el" href="ustring_8h.html#f5002dc5e89378549c68313968790ed7" title="Find the last occurrence of a BMP code point in a string.">u_memrchr</a> <p>
<a class="el" href="ustring_8h.html#55b181aa1237366b05f3b1cc158dda95" title="Find the last occurrence of a substring in a string.">u_strrstr</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fca97af95e51306fedaf103b10fa993"></a><!-- doxytag: member="ustring.h::u_strrchr32" ref="2fca97af95e51306fedaf103b10fa993" args="(const UChar *s, UChar32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strrchr32           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a code point in a string. 
<p>
A surrogate code point is found only if its match in the text is not part of a surrogate pair. A NUL character is found at the string terminator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The code point to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>c</code> in <code>s</code> or <code>NULL</code> if <code>c</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001739">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#16488aa76883493fdecf3b15b0576d59" title="Find the last occurrence of a BMP code point in a string.">u_strrchr</a> <p>
<a class="el" href="ustring_8h.html#14f1a66d758f90167c1bf91aee634b71" title="Find the first occurrence of a code point in a string.">u_memchr32</a> <p>
<a class="el" href="ustring_8h.html#55b181aa1237366b05f3b1cc158dda95" title="Find the last occurrence of a substring in a string.">u_strrstr</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="55b181aa1237366b05f3b1cc158dda95"></a><!-- doxytag: member="ustring.h::u_strrstr" ref="55b181aa1237366b05f3b1cc158dda95" args="(const UChar *s, const UChar *substring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strrstr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>substring</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last occurrence of a substring in a string. 
<p>
The substring is found at code point boundaries. That means that if the substring begins with a trail surrogate or ends with a lead surrogate, then it is found only if these surrogates stand alone in the text. Otherwise, the substring edge units would be matched against halves of surrogate pairs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>substring</em>&nbsp;</td><td>The substring to find (NUL-terminated). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the last occurrence of <code>substring</code> in <code>s</code>, or <code>s</code> itself if the <code>substring</code> is empty, or <code>NULL</code> if <code>substring</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001736">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#074dcf5f1a5b5c4088561ac5ac87883a" title="Find the first occurrence of a substring in a string.">u_strstr</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbbb5b3b858f9e9113beaf315aa7085a"></a><!-- doxytag: member="ustring.h::u_strspn" ref="bbbb5b3b858f9e9113beaf315aa7085a" args="(const UChar *string, const UChar *matchSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strspn           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>matchSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of consecutive characters in <code>string</code>, beginning with the first, that occur somewhere in <code>matchSet</code>. 
<p>
Works just like C's strspn but with Unicode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string in which to search, NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchSet</em>&nbsp;</td><td>A NUL-terminated string defining a set of code points for which to search in the text string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of initial characters in <code>string</code> that do occur in <code>matchSet</code>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#46705ee9aa862bb21100514f96417b17" title="Returns the number of consecutive characters in string, beginning with the first...">u_strcspn</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001742">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="074dcf5f1a5b5c4088561ac5ac87883a"></a><!-- doxytag: member="ustring.h::u_strstr" ref="074dcf5f1a5b5c4088561ac5ac87883a" args="(const UChar *s, const UChar *substring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strstr           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>substring</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first occurrence of a substring in a string. 
<p>
The substring is found at code point boundaries. That means that if the substring begins with a trail surrogate or ends with a lead surrogate, then it is found only if these surrogates stand alone in the text. Otherwise, the substring edge units would be matched against halves of surrogate pairs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to search (NUL-terminated). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>substring</em>&nbsp;</td><td>The substring to find (NUL-terminated). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the first occurrence of <code>substring</code> in <code>s</code>, or <code>s</code> itself if the <code>substring</code> is empty, or <code>NULL</code> if <code>substring</code> is not in <code>s</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001732">Stable:</a></b></dt><dd>ICU 2.0</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#55b181aa1237366b05f3b1cc158dda95" title="Find the last occurrence of a substring in a string.">u_strrstr</a> <p>
<a class="el" href="ustring_8h.html#47bdb20c28603ab39e66c9e518b5b3b6" title="Find the first occurrence of a substring in a string.">u_strFindFirst</a> <p>
<a class="el" href="ustring_8h.html#0304151e1130c43372d51f97d0fb2b0f" title="Find the last occurrence of a substring in a string.">u_strFindLast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccb09fb94f8b6c7b83162c3a24b698de"></a><!-- doxytag: member="ustring.h::u_strtok_r" ref="ccb09fb94f8b6c7b83162c3a24b698de" args="(UChar *src, const UChar *delim, UChar **saveState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_strtok_r           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>saveState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The string tokenizer API allows an application to break a string into tokens. 
<p>
Unlike strtok(), the saveState (the current pointer within the original string) is maintained in saveState. In the first call, the argument src is a pointer to the string. In subsequent calls to return successive tokens of that string, src must be specified as NULL. The value saveState is set by this function to maintain the function's position within the string, and on each subsequent call you must give this argument the same variable. This function does handle surrogate pairs. This function is similar to the strtok_r() the POSIX Threads Extension (1003.1c-1995) version.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String containing token(s). This string will be modified. After the first call to <a class="el" href="ustring_8h.html#ccb09fb94f8b6c7b83162c3a24b698de" title="The string tokenizer API allows an application to break a string into tokens.">u_strtok_r()</a>, this argument must be NULL to get to the next token. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>Set of delimiter characters (Unicode code points). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>saveState</em>&nbsp;</td><td>The current pointer within the original string, which is set by this function. The saveState parameter should the address of a local variable of type UChar *. (i.e. defined "Uhar *myLocalSaveState" and use &amp;myLocalSaveState for this parameter). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the next token found in src, or NULL when there are no more tokens. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001743">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3ed589f5ce0d550c228ee69bfed58fb"></a><!-- doxytag: member="ustring.h::u_strToLower" ref="e3ed589f5ce0d550c228ee69bfed58fb" args="(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strToLower           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lowercase the characters in a string. 
<p>
Casing is locale-dependent and context-sensitive. The result may be longer or shorter than the original. The source string and the destination buffer are allowed to overlap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>The locale to consider, or "" for the root locale or NULL for the default locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of the result string. It may be greater than destCapacity. In that case, only some of the result was written to the destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001776">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c6202ad4ac954e225aae061b184e450"></a><!-- doxytag: member="ustring.h::u_strToTitle" ref="8c6202ad4ac954e225aae061b184e450" args="(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UBreakIterator *titleIter, const char *locale, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strToTitle           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>titleIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Titlecase a string. 
<p>
Casing is locale-dependent and context-sensitive. Titlecasing uses a break iterator to find the first characters of words that are to be titlecased. It titlecases those characters and lowercases all others.<p>
The titlecase break iterator can be provided to customize for arbitrary styles, using rules and dictionaries beyond the standard iterators. It may be more efficient to always provide an iterator to avoid opening and closing one for each string. The standard titlecase iterator for the root locale implements the algorithm of Unicode TR 21.<p>
This function uses only the setText(), first() and next() methods of the provided break iterator.<p>
The result may be longer or shorter than the original. The source string and the destination buffer are allowed to overlap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>titleIter</em>&nbsp;</td><td>A break iterator to find the first characters of words that are to be titlecased. If none is provided (NULL), then a standard titlecase break iterator is opened. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>The locale to consider, or "" for the root locale or NULL for the default locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of the result string. It may be greater than destCapacity. In that case, only some of the result was written to the destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001777">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="14740e3b734ffa82205d4762fcacb5e1"></a><!-- doxytag: member="ustring.h::u_strToUpper" ref="14740e3b734ffa82205d4762fcacb5e1" args="(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_strToUpper           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uppercase the characters in a string. 
<p>
Casing is locale-dependent and context-sensitive. The result may be longer or shorter than the original. The source string and the destination buffer are allowed to overlap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>The locale to consider, or "" for the root locale or NULL for the default locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of the result string. It may be greater than destCapacity. In that case, only some of the result was written to the destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001775">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="471e6e4857f06b262ceac485b7ffcae4"></a><!-- doxytag: member="ustring.h::u_strToUTF32" ref="471e6e4857f06b262ceac485b7ffcae4" args="(UChar32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>* u_strToUTF32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UChars (UTF-16) to UTF32 units. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of UChar32s). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001786">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ca7af2cf47b116454eed92331594afa"></a><!-- doxytag: member="ustring.h::u_strToUTF8" ref="0ca7af2cf47b116454eed92331594afa" args="(char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* u_strToUTF8           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UChars (UTF-16) to UTF-8 bytes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of chars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001781">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#7a79e37a3b1a261a9326029d2a1b1b80" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8WithSub</a> <p>
<a class="el" href="ustring_8h.html#5f9ff224b11166a106d1b3ac26454cd4" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a79e37a3b1a261a9326029d2a1b1b80"></a><!-- doxytag: member="ustring.h::u_strToUTF8WithSub" ref="7a79e37a3b1a261a9326029d2a1b1b80" args="(char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* u_strToUTF8WithSub           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td>
          <td class="paramname"> <em>subchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pNumSubstitutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UChars (UTF-16) to UTF-8 bytes. 
<p>
Same as <a class="el" href="ustring_8h.html#0ca7af2cf47b116454eed92331594afa" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8()</a> except for the additional subchar which is output for illegal input sequences, instead of stopping with the U_INVALID_CHAR_FOUND error code. With subchar==U_SENTINEL, this function behaves exactly like <a class="el" href="ustring_8h.html#0ca7af2cf47b116454eed92331594afa" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of chars). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subchar</em>&nbsp;</td><td>The substitution character to use in place of an illegal input sequence, or U_SENTINEL if the function is to return with U_INVALID_CHAR_FOUND instead. A substitution character can be any valid Unicode code point (up to U+10FFFF) except for surrogate code points (U+D800..U+DFFF). The recommended value is U+FFFD "REPLACEMENT CHARACTER". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNumSubstitutions</em>&nbsp;</td><td>Output parameter receiving the number of substitutions if subchar&gt;=0. Set to 0 if no substitutions occur or subchar&lt;0. pNumSubstitutions can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Pointer to a standard ICU error code. Its input value must pass the <a class="el" href="utypes_8h.html#527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS()</a> test, or else the function returns immediately. Check for <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a> on output or use with function chaining. (See User Guide for details.) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#0ca7af2cf47b116454eed92331594afa" title="Converts a sequence of UChars (UTF-16) to UTF-8 bytes.">u_strToUTF8</a> <p>
<a class="el" href="ustring_8h.html#0e9b7cd493c351804322ad1805fbe775" title="Converts a sequence of UTF-8 bytes to UChars (UTF-16).">u_strFromUTF8WithSub</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001783">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="184562a078b0a961d9281b0c29bb5406"></a><!-- doxytag: member="ustring.h::u_strToWCS" ref="184562a078b0a961d9281b0c29bb5406" args="(wchar_t *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t* u_strToWCS           </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pDestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a sequence of UChars to wchar_t units. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A buffer for the result string. The result will be zero-terminated if the buffer is large enough. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The size of the buffer (number of wchar_t's). If it is 0, then dest may be NULL and the function will only return the length of the result without writing any of the result string (pre-flighting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestLength</em>&nbsp;</td><td>A pointer to receive the number of units written to the destination. If pDestLength!=NULL then *pDestLength is always set to the number of output units corresponding to the transformation of all the input units, even in case of a buffer overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The original source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>The length of the original string. If -1, then src must be zero-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>Must be a valid pointer to an error code value, which must not indicate a failure before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to destination buffer. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001779">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f2d5d46acef8e0eac711bef15e7531f"></a><!-- doxytag: member="ustring.h::u_uastrcpy" ref="0f2d5d46acef8e0eac711bef15e7531f" args="(UChar *dst, const char *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_uastrcpy           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a byte string encoded in the default codepage to a ustring. 
<p>
Adds a null terminator. Performs a host byte to UChar conversion<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001757">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ac7463dd6e3e36128aad288eacace8f"></a><!-- doxytag: member="ustring.h::u_uastrncpy" ref="7ac7463dd6e3e36128aad288eacace8f" args="(UChar *dst, const char *src, int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* u_uastrncpy           </td>
          <td>(</td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a byte string encoded in the default codepage to a ustring. 
<p>
Copies at most <code>n</code> characters. The result will be null terminated if the length of <code>src</code> is less than <code>n</code>. Performs a host byte to UChar conversion<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of characters to copy. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to <code>dst</code>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001758">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7aad56a2a6f7cbe3b2fb802a218d239b"></a><!-- doxytag: member="ustring.h::u_unescape" ref="7aad56a2a6f7cbe3b2fb802a218d239b" args="(const char *src, UChar *dest, int32_t destCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t u_unescape           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unescape a string of characters and write the resulting Unicode characters to the destination buffer. 
<p>
The following escape sequences are recognized:<p>
\uhhhh 4 hex digits; h in [0-9A-Fa-f] \Uhhhhhhhh 8 hex digits \xhh 1-2 hex digits \x{h...} 1-8 hex digits \ooo 1-3 octal digits; o in [0-7] \cX control-X; X is masked with 0x1F<p>
as well as the standard ANSI C escapes:<p>
\a =&gt; U+0007, \b =&gt; U+0008, \t =&gt; U+0009, \n =&gt; U+000A, \v =&gt; U+000B, \f =&gt; U+000C, \r =&gt; U+000D, \e =&gt; U+001B, \" =&gt; U+0022, \' =&gt; U+0027, \? =&gt; U+003F, \\ =&gt; U+005C<p>
Anything else following a backslash is generically escaped. For example, "[a\\-z]" returns "[a-z]".<p>
If an escape sequence is ill-formed, this method returns an empty string. An example of an ill-formed sequence is "\\u" followed by fewer than 4 hex digits.<p>
The above characters are recognized in the compiler's codepage, that is, they are coded as 'u', '\', etc. Characters that are not parts of escape sequences are converted using <a class="el" href="putil_8h.html#d2ba2f88b01ea212f2bfbe2c6b0854a7" title="Convert char characters to UChar characters.">u_charsToUChars()</a>.<p>
This function is similar to <a class="el" href="classUnicodeString.html#bb3f5f6eb82c5689fcfeb8f79d5ca2bf" title="Unescape a string of characters and return a string containing the result.">UnicodeString::unescape()</a> but not identical to it. The latter takes a source <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, so it does escape recognition but no conversion.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>a zero-terminated string of invariant characters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>pointer to buffer to receive converted and unescaped text and, if there is room, a zero terminator. May be NULL for preflighting, in which case no UChars will be written, but the return value will still be valid. On error, an empty string is stored here (if possible). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>the number of UChars that may be written at dest. Ignored if dest == NULL. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of unescaped string. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt</a> <p>
<a class="el" href="classUnicodeString.html#bb3f5f6eb82c5689fcfeb8f79d5ca2bf" title="Unescape a string of characters and return a string containing the result.">UnicodeString::unescape()</a> <p>
<a class="el" href="classUnicodeString.html#f94aa1c7dafa0c151bf0fcbe32d69ded" title="Unescape a single escape sequence and return the represented character.">UnicodeString::unescapeAt()</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001772">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="82a0eed3cd4ec580c996301c0b1a73b0"></a><!-- doxytag: member="ustring.h::u_unescapeAt" ref="82a0eed3cd4ec580c996301c0b1a73b0" args="(UNESCAPE_CHAR_AT charAt, int32_t *offset, int32_t length, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U_CDECL_END <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> u_unescapeAt           </td>
          <td>(</td>
          <td class="paramtype">UNESCAPE_CHAR_AT&nbsp;</td>
          <td class="paramname"> <em>charAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unescape a single sequence. 
<p>
The character at offset-1 is assumed (without checking) to be a backslash. This method takes a callback pointer to a function that returns the UChar at a given offset. By varying this callback, ICU functions are able to unescape char* strings, <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> objects, and UFILE pointers.<p>
If offset is out of range, or if the escape sequence is ill-formed, (UChar32)0xFFFFFFFF is returned. See documentation of <a class="el" href="ustring_8h.html#7aad56a2a6f7cbe3b2fb802a218d239b" title="Unescape a string of characters and write the resulting Unicode characters to the...">u_unescape()</a> for a list of recognized sequences.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>charAt</em>&nbsp;</td><td>callback function that returns a UChar of the source text given an offset and a context pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>pointer to the offset that will be passed to charAt. The offset value will be updated upon return to point after the last parsed character of the escape sequence. On error the offset is unchanged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the number of characters in the source text. The last character of the source text is considered to be at offset length-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>an opaque pointer passed directly into charAt. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the character represented by the escape sequence at offset, or (UChar32)0xFFFFFFFF on error. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#7aad56a2a6f7cbe3b2fb802a218d239b" title="Unescape a string of characters and write the resulting Unicode characters to the...">u_unescape()</a> <p>
<a class="el" href="classUnicodeString.html#bb3f5f6eb82c5689fcfeb8f79d5ca2bf" title="Unescape a string of characters and return a string containing the result.">UnicodeString::unescape()</a> <p>
<a class="el" href="classUnicodeString.html#f94aa1c7dafa0c151bf0fcbe32d69ded" title="Unescape a single escape sequence and return the represented character.">UnicodeString::unescapeAt()</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001774">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba21ae6407ec5fc560be58bbc35af6a2"></a><!-- doxytag: member="ustring.h::UChar" ref="ba21ae6407ec5fc560be58bbc35af6a2" args="(U_CALLCONV *UNESCAPE_CHAR_AT)(int32_t offset" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U_CDECL_BEGIN typedef UChar           </td>
          <td>(</td>
          <td class="paramtype">U_CALLCONV *&nbsp;</td>
          <td class="paramname"> <em>UNESCAPE_CHAR_AT</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function for <a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt()</a> that returns a character of the source text given an offset and a context pointer. 
<p>
The context pointer will be whatever is passed into <a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>pointer to the offset that will be passed to <a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>an opaque pointer passed directly into <a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the character represented by the escape sequence at offset </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ustring_8h.html#82a0eed3cd4ec580c996301c0b1a73b0" title="Unescape a single sequence.">u_unescapeAt</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001773">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 28 17:50:06 2008 for ICU 3.8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
