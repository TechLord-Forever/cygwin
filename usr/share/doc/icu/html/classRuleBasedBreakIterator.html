<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ICU 3.8: RuleBasedBreakIterator Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RuleBasedBreakIterator Class Reference</h1><!-- doxytag: class="RuleBasedBreakIterator" --><!-- doxytag: inherits="BreakIterator" -->A subclass of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose behavior is specified using a list of rules.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="rbbi_8h-source.html">rbbi.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for RuleBasedBreakIterator:</div>
<div class="dynsection">

<p><center><img src="classRuleBasedBreakIterator.png" usemap="#RuleBasedBreakIterator_map" border="0" alt=""></center>
<map name="RuleBasedBreakIterator_map">
<area href="classBreakIterator.html" alt="BreakIterator" shape="rect" coords="0,112,145,136">
<area href="classUObject.html" alt="UObject" shape="rect" coords="0,56,145,80">
<area href="classUMemory.html" alt="UMemory" shape="rect" coords="0,0,145,24">
</map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#c29e42ef56e0756152c830a23bd5adfb">RuleBasedBreakIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#c29e42ef56e0756152c830a23bd5adfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#b601ffba9b8c11489d506a726027db32">RuleBasedBreakIterator</a> (const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#b601ffba9b8c11489d506a726027db32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#93f3f8807dc8bc2fcbb287a59c665003">RuleBasedBreakIterator</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;rules, <a class="el" href="structUParseError.html">UParseError</a> &amp;parseError, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string.  <a href="#93f3f8807dc8bc2fcbb287a59c665003"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#1ab0da227d0a45942c29f2a5df3639cb">RuleBasedBreakIterator</a> (<a class="el" href="udata_8h.html#cffec83601fda29bd4750b24f829f56b">UDataMemory</a> *image, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor uses the udata interface to create a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose internal tables live in a memory-mapped file.  <a href="#1ab0da227d0a45942c29f2a5df3639cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#f97d5993340441b4470508d5063e7662">~RuleBasedBreakIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#f97d5993340441b4470508d5063e7662"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#d6f0b26c45901e817d693008bf03078c">operator=</a> (const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#d6f0b26c45901e817d693008bf03078c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#f1e72eda19a90fd2a729bddd824345d7">operator==</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;that) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#f1e72eda19a90fd2a729bddd824345d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#830c4be152a82f2a80e6059c00ad3451">operator!=</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;that) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not-equal operator.  <a href="#830c4be152a82f2a80e6059c00ad3451"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#805badacaa522dee2ec8c3e09ab5659f">clone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one.  <a href="#805badacaa522dee2ec8c3e09ab5659f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#01daa6b1966339e69d7e4e805f193491">hashCode</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a hash code for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>.  <a href="#01daa6b1966339e69d7e4e805f193491"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#813110eca17a45c2563c623a1ed9d5f1">getRules</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the description used to create this iterator.  <a href="#813110eca17a45c2563c623a1ed9d5f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#21542dea2f8d1d12629484f38292301d">getText</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#afe5882170adf4e756d077db58cce0a4">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="#afe5882170adf4e756d077db58cce0a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#002e744aad6039dd379f63225052f0b1">adoptText</a> (<a class="el" href="classCharacterIterator.html">CharacterIterator</a> *newText)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#002e744aad6039dd379f63225052f0b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#3c43a81c024eb388aa807557ec1218fd">setText</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;newText)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#3c43a81c024eb388aa807557ec1218fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#eb3cf0fe922a95d24978a3014c8f79b2">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="#eb3cf0fe922a95d24978a3014c8f79b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#45707d96406f1b0027ce65c79ac36c67">first</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text.  <a href="#45707d96406f1b0027ce65c79ac36c67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#b57d12a60328d31fbc859591d9fd1272">last</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current iteration position to the end of the text.  <a href="#b57d12a60328d31fbc859591d9fd1272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#0fbb590a8a0f62627afe40ce4b4f5730">next</a> (int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator either forward or backward the specified number of steps.  <a href="#0fbb590a8a0f62627afe40ce4b4f5730"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#16fe1b082e7e67d9f0dbc3c277c642d7">next</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator to the next boundary position.  <a href="#16fe1b082e7e67d9f0dbc3c277c642d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#9aad4e7020f9a0b7b7627ee8ce0c2e9c">previous</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator backwards, to the last boundary preceding this one.  <a href="#9aad4e7020f9a0b7b7627ee8ce0c2e9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#0407bc1809b35c7af19cfa0539067841">following</a> (int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the iterator to refer to the first boundary position following the specified position.  <a href="#0407bc1809b35c7af19cfa0539067841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#f63093f20c0ab16c597d104573ed65f1">preceding</a> (int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the iterator to refer to the last boundary position before the specified position.  <a href="#f63093f20c0ab16c597d104573ed65f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#d23e9f31feed57dee61b1d45fcb3dbfc">isBoundary</a> (int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the specfied position is a boundary position.  <a href="#d23e9f31feed57dee61b1d45fcb3dbfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#c7083ccc926c0b72c08ea105a01321c8">current</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current iteration position.  <a href="#c7083ccc926c0b72c08ea105a01321c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#827e0fe5c71af0c2608304cf54e6400f">getRuleStatus</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status tag from the break rule that determined the most recently returned break position.  <a href="#827e0fe5c71af0c2608304cf54e6400f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#924d98d0bc7aea9568034c5257542d0c">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the status (tag) values from the break rule(s) that determined the most recently returned break position.  <a href="#924d98d0bc7aea9568034c5257542d0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="utypes_8h.html#22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#c601c2347870413f79995d843687a470">getDynamicClassID</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a unique class ID POLYMORPHICALLY.  <a href="#c601c2347870413f79995d843687a470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#3e120994761da087377fb1e6b5dccf18">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it.  <a href="#3e120994761da087377fb1e6b5dccf18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#1852625b37eccd5b78a8c6993e49b309">getBinaryRules</a> (uint32_t &amp;length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future.  <a href="#1852625b37eccd5b78a8c6993e49b309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#dec544981344804a4abb5fd3b3826d7d">setBreakType</a> (int32_t type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the type of the break iterator.  <a href="#dec544981344804a4abb5fd3b3826d7d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="utypes_8h.html#22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#dc73faf663185bdd27441bd42f97a68a">getStaticClassID</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the class ID for this class.  <a href="#dc73faf663185bdd27441bd42f97a68a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a57ab1ae99efe23f07a73ddf4389027c">RuleBasedBreakIterator</a> (RBBIDataHeader *data, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from a flattened set of RBBI data in malloced memory.  <a href="#a57ab1ae99efe23f07a73ddf4389027c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#5052a806f483ca004e8197a27b7d0ce4">reset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps caches and performs other actions associated with a complete change in text or iteration position.  <a href="#5052a806f483ca004e8197a27b7d0ce4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#dbb69236c763c8b7abdac190964c3d1a">init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common initialization function, used by constructors and bufferClone.  <a href="#dbb69236c763c8b7abdac190964c3d1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#7a4dd96ffe78373ff59af253d95d4d2c">checkDictionary</a> (int32_t startPos, int32_t endPos, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the function that actually implements dictionary-based breaking.  <a href="#7a4dd96ffe78373ff59af253d95d4d2c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#419b7e787fe701da59edf938ec338348">fText</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structUText.html" title="UText struct.">UText</a> through which this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> accesses the text.  <a href="#419b7e787fe701da59edf938ec338348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCharacterIterator.html">CharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#e31cd176a5f569eeaad260232078e1c4">fCharIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A character iterator that refers to the same text as the <a class="el" href="structUText.html" title="UText struct.">UText</a>, above.  <a href="#e31cd176a5f569eeaad260232078e1c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStringCharacterIterator.html">StringCharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#b167d8622058e5c0d417dd43ef83edda">fSCharIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the input text is provided by a <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, this will point to a characterIterator that wraps that data.  <a href="#b167d8622058e5c0d417dd43ef83edda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d276784df08fcac79d039533a1341cdb"></a><!-- doxytag: member="RuleBasedBreakIterator::fDCharIter" ref="d276784df08fcac79d039533a1341cdb" args="" -->
<a class="el" href="classUCharCharacterIterator.html">UCharCharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#d276784df08fcac79d039533a1341cdb">fDCharIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the input text is provided by a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this dummy <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over an empty string will be returned from <a class="el" href="classBreakIterator.html#b12b76622eaa6df7d0df48778f5de1aa" title="Return a CharacterIterator over the text being analyzed.">getText()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RBBIDataWrapper *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#9e4c4ce2df8bd5ec86eb24029f536fc1">fData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rule data for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> instance.  <a href="#9e4c4ce2df8bd5ec86eb24029f536fc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#0334069f3c4a9384836be7e76f8553a3">fLastRuleStatusIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the Rule {tag} values for the most recent match.  <a href="#0334069f3c4a9384836be7e76f8553a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#724ee27f3375cb4a18a0268ddddc4e78">fLastStatusIndexValid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule tag value valid flag.  <a href="#724ee27f3375cb4a18a0268ddddc4e78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#7491e4622823085f822618797ac62643">fDictionaryCharCount</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counter for the number of characters encountered with the "dictionary" flag set.  <a href="#7491e4622823085f822618797ac62643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#56b061a55c91c2f45263213b4188e19d">fCachedBreakPositions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When a range of characters is divided up using the dictionary, the break positions that are discovered are stored here, preventing us from having to use either the dictionary or the state table again until the iterator leaves this range of text.  <a href="#56b061a55c91c2f45263213b4188e19d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#e592ba2301f6064f2f50d70196517886">fNumCachedBreakPositions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of elements in fCachedBreakPositions.  <a href="#e592ba2301f6064f2f50d70196517886"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#65ae2b4eadd5389543d7b69d2c965c9f">fPositionInCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if fCachedBreakPositions is not null, this indicates which item in the cache the current iteration position refers to  <a href="#65ae2b4eadd5389543d7b69d2c965c9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UStack *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#f7beaa3fd16091bd2dec10e67ccec22f">fLanguageBreakEngines</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, UStack of LanguageBreakEngine objects that might handle dictionary characters.  <a href="#f7beaa3fd16091bd2dec10e67ccec22f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">UnhandledEngine *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#6f39d4df45fbf35c61ac58df2746f1e9">fUnhandledBreakEngine</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, the special LanguageBreakEngine used for handling characters that are in the dictionary set, but not handled by any LangugageBreakEngine.  <a href="#6f39d4df45fbf35c61ac58df2746f1e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#f2304ecb86e7e4e50c3aab9f4b0c1aef">fBreakType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the break iterator, or -1 if it has not been set.  <a href="#f2304ecb86e7e4e50c3aab9f4b0c1aef"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17ce03f12f5fa8688859b25e2bf60938"></a><!-- doxytag: member="RuleBasedBreakIterator::RBBIRuleBuilder" ref="17ce03f12f5fa8688859b25e2bf60938" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>RBBIRuleBuilder</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#5fbb7407696454879cf016b20a0380f0">BreakIterator</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A subclass of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose behavior is specified using a list of rules. 
<p>
Instances of this class are most commonly created by the factory methods of <a class="el" href="classBreakIterator.html#fc0385b348d5156de7cc45f34ba660fa" title="Create BreakIterator for word-breaks using the given locale.">BreakIterator::createWordInstance()</a>, <a class="el" href="classBreakIterator.html#83ed35d09a8ab8b18ace13e073cf8434" title="Create BreakIterator for line-breaks using specified locale.">BreakIterator::createLineInstance()</a>, etc., and then used via the abstract API in class <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a><p>
See the ICU User Guide for information on Break Iterator Rules.<p>
This class is not intended to be subclassed. (Class DictionaryBasedBreakIterator is a subclass, but that relationship is effectively internal to the ICU implementation. The subclassing interface to RulesBasedBreakIterator is not part of the ICU API, and may not remain stable. 
<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00065">65</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a57ab1ae99efe23f07a73ddf4389027c"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="a57ab1ae99efe23f07a73ddf4389027c" args="(RBBIDataHeader *data, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramtype">RBBIDataHeader *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor from a flattened set of RBBI data in malloced memory. 
<p>
RulesBasedBreakIterators built from a custom set of rules are created via this constructor; the rules are compiled into memory, then the break iterator is constructed here.<p>
The break iterator adopts the memory, and will free it when done. <dl compact><dt><b><a class="el" href="internal.html#_internal000027">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c29e42ef56e0756152c830a23bd5adfb"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="c29e42ef56e0756152c830a23bd5adfb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
Creates an empty shell of an iterator, with no rules or text to iterate over. Object can subsequently be assigned to. <dl compact><dt><b><a class="el" href="stable.html#_stable000224">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b601ffba9b8c11489d506a726027db32"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="b601ffba9b8c11489d506a726027db32" args="(const RuleBasedBreakIterator &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
Will produce a break iterator with the same behavior, and which iterates over the same text, as the one passed in. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> passed to be copied </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000225">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="93f3f8807dc8bc2fcbb287a59c665003"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="93f3f8807dc8bc2fcbb287a59c665003" args="(const UnicodeString &amp;rules, UParseError &amp;parseError, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parseError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rules</em>&nbsp;</td><td>The break rules to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parseError</em>&nbsp;</td><td>In the event of a syntax error in the rules, provides the location within the rules of the problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Information on any errors encountered. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000226">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ab0da227d0a45942c29f2a5df3639cb"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="1ab0da227d0a45942c29f2a5df3639cb" args="(UDataMemory *image, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="udata_8h.html#cffec83601fda29bd4750b24f829f56b">UDataMemory</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This constructor uses the udata interface to create a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose internal tables live in a memory-mapped file. 
<p>
"image" is an ICU UDataMemory handle for the pre-compiled break iterator tables. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>handle to the memory image for the break iterator data. Ownership of the UDataMemory handle passes to the Break Iterator, which will be responsible for closing it when it is no longer needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Information on any errors encountered. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="udata_8h.html#3d908d77900b182403a375793ad35a86" title="Convenience function.">udata_open</a> <p>
<a class="el" href="classRuleBasedBreakIterator.html#1852625b37eccd5b78a8c6993e49b309" title="Return the binary form of compiled break rules, which can then be used to create...">getBinaryRules</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000227">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f97d5993340441b4470508d5063e7662"></a><!-- doxytag: member="RuleBasedBreakIterator::~RuleBasedBreakIterator" ref="f97d5993340441b4470508d5063e7662" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RuleBasedBreakIterator::~RuleBasedBreakIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000228">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d6f0b26c45901e817d693008bf03078c"></a><!-- doxytag: member="RuleBasedBreakIterator::operator=" ref="d6f0b26c45901e817d693008bf03078c" args="(const RuleBasedBreakIterator &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; RuleBasedBreakIterator::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
Sets this iterator to have the same behavior, and iterate over the same text, as the one passed in. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The RuleBasedBreakItertor passed in </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the newly created <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000229">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1e72eda19a90fd2a729bddd824345d7"></a><!-- doxytag: member="RuleBasedBreakIterator::operator==" ref="f1e72eda19a90fd2a729bddd824345d7" args="(const BreakIterator &amp;that) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality operator. 
<p>
Returns TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> to be compared for equality </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000230">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#def035120a8805b350ae7ec789b43093">BreakIterator</a>.</p>

<p>Referenced by <a class="el" href="rbbi_8h-source.html#l00694">operator!=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="830c4be152a82f2a80e6059c00ad3451"></a><!-- doxytag: member="RuleBasedBreakIterator::operator!=" ref="830c4be152a82f2a80e6059c00ad3451" args="(const BreakIterator &amp;that) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Not-equal operator. 
<p>
If operator== returns TRUE, this returns FALSE, and vice versa. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if both BreakIterators are not same. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000231">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classBreakIterator.html#188fb5d54bae55e4f9ea9730e44919a5">BreakIterator</a>.</p>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00694">694</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

<p>References <a class="el" href="classRuleBasedBreakIterator.html#f1e72eda19a90fd2a729bddd824345d7">operator==()</a>.</p>

</div>
</div><p>
<a class="anchor" name="805badacaa522dee2ec8c3e09ab5659f"></a><!-- doxytag: member="RuleBasedBreakIterator::clone" ref="805badacaa522dee2ec8c3e09ab5659f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* RuleBasedBreakIterator::clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one. 
<p>
Differs from the copy constructor in that it is polymorphic, and will correctly clone (copy) a derived class. <a class="el" href="classBreakIterator.html#a17a81d41fa791049a10c37594dad88f" title="Return a polymorphic copy of this object.">clone()</a> is thread safe. Multiple threads may simultaeneously clone the same source break iterator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000232">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a17a81d41fa791049a10c37594dad88f">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="01daa6b1966339e69d7e4e805f193491"></a><!-- doxytag: member="RuleBasedBreakIterator::hashCode" ref="01daa6b1966339e69d7e4e805f193491" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::hashCode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a hash code for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A hash code </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000233">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="813110eca17a45c2563c623a1ed9d5f1"></a><!-- doxytag: member="RuleBasedBreakIterator::getRules" ref="813110eca17a45c2563c623a1ed9d5f1" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; RuleBasedBreakIterator::getRules           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the description used to create this iterator. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the description used to create this iterator </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000234">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="21542dea2f8d1d12629484f38292301d"></a><!-- doxytag: member="RuleBasedBreakIterator::getText" ref="21542dea2f8d1d12629484f38292301d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a>&amp; RuleBasedBreakIterator::getText           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed. The returned character iterator is owned by the break iterator, and must not be deleted by the caller. Repeated calls to this function may return the same <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a>.  <p>
The returned character iterator must not be used concurrently with the break iterator. If concurrent operation is needed, clone the returned character iterator first and operate on the clone.  <p>
When the break iterator is operating on text supplied via a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this function will fail. Lacking any way to signal failures, it returns an <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> containing no text. The function <a class="el" href="classRuleBasedBreakIterator.html#afe5882170adf4e756d077db58cce0a4" title="Get a UText for the text being analyzed.">getUText()</a> provides similar functionality, is reliable, and is more efficient. <p>
TODO: deprecate this function?<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator over the text being analyzed. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000235">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#b12b76622eaa6df7d0df48778f5de1aa">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="afe5882170adf4e756d077db58cce0a4"></a><!-- doxytag: member="RuleBasedBreakIterator::getUText" ref="afe5882170adf4e756d077db58cce0a4" args="(UText *fillIn, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RuleBasedBreakIterator::getUText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed. 
<p>
The returned <a class="el" href="structUText.html" title="UText struct.">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fillIn</em>&nbsp;</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> to be filled in. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives any error codes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current <a class="el" href="structUText.html" title="UText struct.">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be returned. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000236">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#724d55795f3edb7748e6d6dffd80d926">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="002e744aad6039dd379f63225052f0b1"></a><!-- doxytag: member="RuleBasedBreakIterator::adoptText" ref="002e744aad6039dd379f63225052f0b1" args="(CharacterIterator *newText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::adoptText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCharacterIterator.html">CharacterIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>newText</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the iterator to analyze a new piece of text. 
<p>
This function resets the current iteration position to the beginning of the text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newText</em>&nbsp;</td><td>An iterator over the text to analyze. The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> takes ownership of the character iterator. The caller MUST NOT delete it! </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000237">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#729dbe9a6437070d9fb056c6c7589563">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="3c43a81c024eb388aa807557ec1218fd"></a><!-- doxytag: member="RuleBasedBreakIterator::setText" ref="3c43a81c024eb388aa807557ec1218fd" args="(const UnicodeString &amp;newText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setText           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newText</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the iterator to analyze a new piece of text. 
<p>
This function resets the current iteration position to the beginning of the text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newText</em>&nbsp;</td><td>The text to analyze. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000238">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#c50a6618fe83b9b96a7a9213c5da3f21">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="eb3cf0fe922a95d24978a3014c8f79b2"></a><!-- doxytag: member="RuleBasedBreakIterator::setText" ref="eb3cf0fe922a95d24978a3014c8f79b2" args="(UText *text, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>. 
<p>
The iterator position is reset to the start.<p>
This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> used to change the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Receives any error codes. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000239">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#74d79d97bbc2265753486704111d29eb">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="45707d96406f1b0027ce65c79ac36c67"></a><!-- doxytag: member="RuleBasedBreakIterator::first" ref="45707d96406f1b0027ce65c79ac36c67" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::first           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current iteration position to the beginning of the text. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset of the beginning of the text. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000240">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#e09bd26e3559e18e8e46699075f477e4">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="b57d12a60328d31fbc859591d9fd1272"></a><!-- doxytag: member="RuleBasedBreakIterator::last" ref="b57d12a60328d31fbc859591d9fd1272" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::last           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current iteration position to the end of the text. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text's past-the-end offset. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000241">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#b21a3083a947dd4b4f3653a0a51080c2">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fbb590a8a0f62627afe40ce4b4f5730"></a><!-- doxytag: member="RuleBasedBreakIterator::next" ref="0fbb590a8a0f62627afe40ce4b4f5730" args="(int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::next           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the iterator either forward or backward the specified number of steps. 
<p>
Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling <a class="el" href="classRuleBasedBreakIterator.html#16fe1b082e7e67d9f0dbc3c277c642d7" title="Advances the iterator to the next boundary position.">next()</a> or <a class="el" href="classRuleBasedBreakIterator.html#9aad4e7020f9a0b7b7627ee8ce0c2e9c" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of steps to move. The sign indicates the direction (negative is backwards, and positive is forwards). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character offset of the boundary position n boundaries away from the current one. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000242">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#bc5223195e31b93657dffa305592bcd7">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="16fe1b082e7e67d9f0dbc3c277c642d7"></a><!-- doxytag: member="RuleBasedBreakIterator::next" ref="16fe1b082e7e67d9f0dbc3c277c642d7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::next           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the iterator to the next boundary position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The position of the first boundary after this one. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000243">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#68f3b6be789195b55204a6d86d58a8ad">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="9aad4e7020f9a0b7b7627ee8ce0c2e9c"></a><!-- doxytag: member="RuleBasedBreakIterator::previous" ref="9aad4e7020f9a0b7b7627ee8ce0c2e9c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::previous           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator backwards, to the last boundary preceding this one. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The position of the last boundary position preceding this one. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000244">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#c4f27d685b8c1bacbad7e27a6af141f2">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="0407bc1809b35c7af19cfa0539067841"></a><!-- doxytag: member="RuleBasedBreakIterator::following" ref="0407bc1809b35c7af19cfa0539067841" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::following           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the iterator to refer to the first boundary position following the specified position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position from which to begin searching for a break position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The position of the first break after the current position. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000245">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#57f98a77f67b2ca34c26ee2e77d76e09">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="f63093f20c0ab16c597d104573ed65f1"></a><!-- doxytag: member="RuleBasedBreakIterator::preceding" ref="f63093f20c0ab16c597d104573ed65f1" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::preceding           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the iterator to refer to the last boundary position before the specified position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position to begin searching for a break from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The position of the last boundary before the starting position. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000246">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#9230e330fd08bad1b6c278d322ef2385">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="d23e9f31feed57dee61b1d45fcb3dbfc"></a><!-- doxytag: member="RuleBasedBreakIterator::isBoundary" ref="d23e9f31feed57dee61b1d45fcb3dbfc" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::isBoundary           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the specfied position is a boundary position. 
<p>
As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000247">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#9ac740557f08c879cceffdbb4a15fe7b">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="c7083ccc926c0b72c08ea105a01321c8"></a><!-- doxytag: member="RuleBasedBreakIterator::current" ref="c7083ccc926c0b72c08ea105a01321c8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::current           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current iteration position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current iteration position. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000248">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#36835a8123d823f333af822d9c7cb8a6">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="827e0fe5c71af0c2608304cf54e6400f"></a><!-- doxytag: member="RuleBasedBreakIterator::getRuleStatus" ref="827e0fe5c71af0c2608304cf54e6400f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::getRuleStatus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the status tag from the break rule that determined the most recently returned break position. 
<p>
For break rules that do not specify a status, a default value of 0 is returned. If more than one break rule would cause a boundary to be located at some position in the text, the numerically largest of the applicable status values is returned. <p>
Of the standard types of ICU break iterators, only word break and line break provide status values. The values are defined in the header file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">ubrk.h</a>. For Word breaks, the status allows distinguishing between words that contain alphabetic letters, "words" that appear to be numbers, punctuation and spaces, words containing ideographic characters, and more. For Line Break, the status distinguishes between hard (mandatory) breaks and soft (potential) break positions. <p>
<code><a class="el" href="classRuleBasedBreakIterator.html#827e0fe5c71af0c2608304cf54e6400f" title="Return the status tag from the break rule that determined the most recently returned...">getRuleStatus()</a></code> can be called after obtaining a boundary position from <code><a class="el" href="classRuleBasedBreakIterator.html#16fe1b082e7e67d9f0dbc3c277c642d7" title="Advances the iterator to the next boundary position.">next()</a></code>, <code><a class="el" href="classRuleBasedBreakIterator.html#9aad4e7020f9a0b7b7627ee8ce0c2e9c" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a></code>, or any other break iterator functions that returns a boundary position. <p>
When creating custom break rules, one is free to define whatever status values may be convenient for the application. <p>
Note: this function is not thread safe. It should not have been declared const, and the const remains only for compatibility reasons. (The function is logically const, but not bit-wise const). <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the status from the break rule that determined the most recently returned break position.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9" title="Enum constants for the word break tags returned by getRuleStatus().">UWordBreak</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000249">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="924d98d0bc7aea9568034c5257542d0c"></a><!-- doxytag: member="RuleBasedBreakIterator::getRuleStatusVec" ref="924d98d0bc7aea9568034c5257542d0c" args="(int32_t *fillInVec, int32_t capacity, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::getRuleStatusVec           </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the status (tag) values from the break rule(s) that determined the most recently returned break position. 
<p>
The returned status value(s) are stored into an array provided by the caller. The values are stored in sorted (ascending) order. If the capacity of the output array is insufficient to hold the data, the output will be truncated to the available length, and a U_BUFFER_OVERFLOW_ERROR will be signaled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fillInVec</em>&nbsp;</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attemtping to store any values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives error codes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of rule status values from rules that determined the most recent boundary returned by the break iterator. In the event of a U_BUFFER_OVERFLOW_ERROR, the return value is the total number of status values that were available, not the reduced number that were actually returned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classRuleBasedBreakIterator.html#827e0fe5c71af0c2608304cf54e6400f" title="Return the status tag from the break rule that determined the most recently returned...">getRuleStatus</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000250">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c601c2347870413f79995d843687a470"></a><!-- doxytag: member="RuleBasedBreakIterator::getDynamicClassID" ref="c601c2347870413f79995d843687a470" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="utypes_8h.html#22af10545208a455a6e884008df48e9f">UClassID</a> RuleBasedBreakIterator::getDynamicClassID           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a unique class ID POLYMORPHICALLY. 
<p>
Pure virtual override. This method is to implement a simple version of RTTI, since not all C++ compilers support genuine RTTI. Polymorphic <a class="el" href="classRuleBasedBreakIterator.html#f1e72eda19a90fd2a729bddd824345d7" title="Equality operator.">operator==()</a> and <a class="el" href="classBreakIterator.html#a17a81d41fa791049a10c37594dad88f" title="Return a polymorphic copy of this object.">clone()</a> methods call this method.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class ID for this object. All objects of a given class have the same class ID. Objects of other classes have different class IDs. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000251">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#eaf98baae1d91e224ef8ccced5d2266c">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="dc73faf663185bdd27441bd42f97a68a"></a><!-- doxytag: member="RuleBasedBreakIterator::getStaticClassID" ref="dc73faf663185bdd27441bd42f97a68a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="utypes_8h.html#22af10545208a455a6e884008df48e9f">UClassID</a> RuleBasedBreakIterator::getStaticClassID           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the class ID for this class. 
<p>
This is useful only for comparing to a return value from <a class="el" href="classBreakIterator.html#eaf98baae1d91e224ef8ccced5d2266c" title="Return a polymorphic class ID for this object.">getDynamicClassID()</a>. For example:<p>
Base* polymorphic_pointer = createPolymorphicObject(); if (polymorphic_pointer-&gt;<a class="el" href="classBreakIterator.html#eaf98baae1d91e224ef8ccced5d2266c" title="Return a polymorphic class ID for this object.">getDynamicClassID()</a> == Derived::getStaticClassID()) ...<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The class ID for all objects of this class. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000252">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e120994761da087377fb1e6b5dccf18"></a><!-- doxytag: member="RuleBasedBreakIterator::createBufferClone" ref="3e120994761da087377fb1e6b5dccf18" args="(void *stackBuffer, int32_t &amp;BufferSize, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* RuleBasedBreakIterator::createBufferClone           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferSize</em>&nbsp;</td><td>reference to size of allocated space. If BufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If BufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the new clone</dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000028">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#6ea0e9828c9ef650086f4d3a17ce5c61">BreakIterator</a>.</p>

</div>
</div><p>
<a class="anchor" name="1852625b37eccd5b78a8c6993e49b309"></a><!-- doxytag: member="RuleBasedBreakIterator::getBinaryRules" ref="1852625b37eccd5b78a8c6993e49b309" args="(uint32_t &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const uint8_t* RuleBasedBreakIterator::getBinaryRules           </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future. 
<p>
Creating a break iterator from pre-compiled rules is much faster than building one from the source form of the break rules.<p>
The binary data can only be used with the same version of ICU and on the same platform type (processor endian-ness)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Returns the length of the binary data. (Out paramter.)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the binary (compiled) rule data. The storage belongs to the RulesBasedBreakIterator object, not the caller, and must not be modified or deleted. </dd></dl>
<dl compact><dt><b><a class="el" href="internal.html#_internal000029">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5052a806f483ca004e8197a27b7d0ce4"></a><!-- doxytag: member="RuleBasedBreakIterator::reset" ref="5052a806f483ca004e8197a27b7d0ce4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::reset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dumps caches and performs other actions associated with a complete change in text or iteration position. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000030">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dec544981344804a4abb5fd3b3826d7d"></a><!-- doxytag: member="RuleBasedBreakIterator::setBreakType" ref="dec544981344804a4abb5fd3b3826d7d" args="(int32_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setBreakType           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the type of the break iterator. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000031">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbb69236c763c8b7abdac190964c3d1a"></a><!-- doxytag: member="RuleBasedBreakIterator::init" ref="dbb69236c763c8b7abdac190964c3d1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RuleBasedBreakIterator::init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Common initialization function, used by constructors and bufferClone. 
<p>
(Also used by DictionaryBasedBreakIterator::createBufferClone().) <dl compact><dt><b><a class="el" href="internal.html#_internal000032">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a4dd96ffe78373ff59af253d95d4d2c"></a><!-- doxytag: member="RuleBasedBreakIterator::checkDictionary" ref="7a4dd96ffe78373ff59af253d95d4d2c" args="(int32_t startPos, int32_t endPos, UBool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t RuleBasedBreakIterator::checkDictionary           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the function that actually implements dictionary-based breaking. 
<p>
Covering at least the range from startPos to endPos, it checks for dictionary characters, and if it finds them determines the appropriate object to deal with them. It may cache found breaks in fCachedBreakPositions as it goes. It may well also look at text outside the range startPos to endPos. If going forward, endPos is the normal Unicode break result, and if goind in reverse, startPos is the normal Unicode break result <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>The start position of a range of text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endPos</em>&nbsp;</td><td>The end position of a range of text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>The call is for the reverse direction </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="internal.html#_internal000035">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="5fbb7407696454879cf016b20a0380f0"></a><!-- doxytag: member="RuleBasedBreakIterator::BreakIterator" ref="5fbb7407696454879cf016b20a0380f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBreakIterator.html">BreakIterator</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000028">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00188">188</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="419b7e787fe701da59edf938ec338348"></a><!-- doxytag: member="RuleBasedBreakIterator::fText" ref="419b7e787fe701da59edf938ec338348" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUText.html">UText</a>* <a class="el" href="classRuleBasedBreakIterator.html#419b7e787fe701da59edf938ec338348">RuleBasedBreakIterator::fText</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="structUText.html" title="UText struct.">UText</a> through which this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> accesses the text. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000016">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00072">72</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e31cd176a5f569eeaad260232078e1c4"></a><!-- doxytag: member="RuleBasedBreakIterator::fCharIter" ref="e31cd176a5f569eeaad260232078e1c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCharacterIterator.html">CharacterIterator</a>* <a class="el" href="classRuleBasedBreakIterator.html#e31cd176a5f569eeaad260232078e1c4">RuleBasedBreakIterator::fCharIter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A character iterator that refers to the same text as the <a class="el" href="structUText.html" title="UText struct.">UText</a>, above. 
<p>
Only included for compatibility with old API, which was based on CharacterIterators. Value may be adopted from outside, or one of fSCharIter or fDCharIter, below. 
<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00079">79</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b167d8622058e5c0d417dd43ef83edda"></a><!-- doxytag: member="RuleBasedBreakIterator::fSCharIter" ref="b167d8622058e5c0d417dd43ef83edda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStringCharacterIterator.html">StringCharacterIterator</a>* <a class="el" href="classRuleBasedBreakIterator.html#b167d8622058e5c0d417dd43ef83edda">RuleBasedBreakIterator::fSCharIter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When the input text is provided by a <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, this will point to a characterIterator that wraps that data. 
<p>
Needed only for the implementation of <a class="el" href="classBreakIterator.html#b12b76622eaa6df7d0df48778f5de1aa" title="Return a CharacterIterator over the text being analyzed.">getText()</a>, a backwards compatibility issue. 
<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00086">86</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9e4c4ce2df8bd5ec86eb24029f536fc1"></a><!-- doxytag: member="RuleBasedBreakIterator::fData" ref="9e4c4ce2df8bd5ec86eb24029f536fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RBBIDataWrapper* <a class="el" href="classRuleBasedBreakIterator.html#9e4c4ce2df8bd5ec86eb24029f536fc1">RuleBasedBreakIterator::fData</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The rule data for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> instance. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000017">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00099">99</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0334069f3c4a9384836be7e76f8553a3"></a><!-- doxytag: member="RuleBasedBreakIterator::fLastRuleStatusIndex" ref="0334069f3c4a9384836be7e76f8553a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#0334069f3c4a9384836be7e76f8553a3">RuleBasedBreakIterator::fLastRuleStatusIndex</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of the Rule {tag} values for the most recent match. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000018">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00104">104</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="724ee27f3375cb4a18a0268ddddc4e78"></a><!-- doxytag: member="RuleBasedBreakIterator::fLastStatusIndexValid" ref="724ee27f3375cb4a18a0268ddddc4e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> <a class="el" href="classRuleBasedBreakIterator.html#724ee27f3375cb4a18a0268ddddc4e78">RuleBasedBreakIterator::fLastStatusIndexValid</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rule tag value valid flag. 
<p>
Some iterator operations don't intrinsically set the correct tag value. This flag lets us lazily compute the value if we are ever asked for it. <dl compact><dt><b><a class="el" href="internal.html#_internal000019">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00112">112</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7491e4622823085f822618797ac62643"></a><!-- doxytag: member="RuleBasedBreakIterator::fDictionaryCharCount" ref="7491e4622823085f822618797ac62643" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classRuleBasedBreakIterator.html#7491e4622823085f822618797ac62643">RuleBasedBreakIterator::fDictionaryCharCount</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counter for the number of characters encountered with the "dictionary" flag set. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000020">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00119">119</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="56b061a55c91c2f45263213b4188e19d"></a><!-- doxytag: member="RuleBasedBreakIterator::fCachedBreakPositions" ref="56b061a55c91c2f45263213b4188e19d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t* <a class="el" href="classRuleBasedBreakIterator.html#56b061a55c91c2f45263213b4188e19d">RuleBasedBreakIterator::fCachedBreakPositions</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When a range of characters is divided up using the dictionary, the break positions that are discovered are stored here, preventing us from having to use either the dictionary or the state table again until the iterator leaves this range of text. 
<p>
Has the most impact for line breaking. <dl compact><dt><b><a class="el" href="internal.html#_internal000021">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00128">128</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e592ba2301f6064f2f50d70196517886"></a><!-- doxytag: member="RuleBasedBreakIterator::fNumCachedBreakPositions" ref="e592ba2301f6064f2f50d70196517886" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#e592ba2301f6064f2f50d70196517886">RuleBasedBreakIterator::fNumCachedBreakPositions</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of elements in fCachedBreakPositions. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000022">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00134">134</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="65ae2b4eadd5389543d7b69d2c965c9f"></a><!-- doxytag: member="RuleBasedBreakIterator::fPositionInCache" ref="65ae2b4eadd5389543d7b69d2c965c9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#65ae2b4eadd5389543d7b69d2c965c9f">RuleBasedBreakIterator::fPositionInCache</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
if fCachedBreakPositions is not null, this indicates which item in the cache the current iteration position refers to 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000023">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00141">141</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f7beaa3fd16091bd2dec10e67ccec22f"></a><!-- doxytag: member="RuleBasedBreakIterator::fLanguageBreakEngines" ref="f7beaa3fd16091bd2dec10e67ccec22f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UStack* <a class="el" href="classRuleBasedBreakIterator.html#f7beaa3fd16091bd2dec10e67ccec22f">RuleBasedBreakIterator::fLanguageBreakEngines</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If present, UStack of LanguageBreakEngine objects that might handle dictionary characters. 
<p>
Searched from top to bottom to find an object to handle a given character. <dl compact><dt><b><a class="el" href="internal.html#_internal000024">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00150">150</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6f39d4df45fbf35c61ac58df2746f1e9"></a><!-- doxytag: member="RuleBasedBreakIterator::fUnhandledBreakEngine" ref="6f39d4df45fbf35c61ac58df2746f1e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnhandledEngine* <a class="el" href="classRuleBasedBreakIterator.html#6f39d4df45fbf35c61ac58df2746f1e9">RuleBasedBreakIterator::fUnhandledBreakEngine</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If present, the special LanguageBreakEngine used for handling characters that are in the dictionary set, but not handled by any LangugageBreakEngine. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000025">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00159">159</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f2304ecb86e7e4e50c3aab9f4b0c1aef"></a><!-- doxytag: member="RuleBasedBreakIterator::fBreakType" ref="f2304ecb86e7e4e50c3aab9f4b0c1aef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#f2304ecb86e7e4e50c3aab9f4b0c1aef">RuleBasedBreakIterator::fBreakType</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the break iterator, or -1 if it has not been set. 
<p>
<dl compact><dt><b><a class="el" href="internal.html#_internal000026">Internal:</a></b></dt><dd>Do not use. This API is for interal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h-source.html#l00166">166</a> of file <a class="el" href="rbbi_8h-source.html">rbbi.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rbbi_8h-source.html">rbbi.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 28 17:50:14 2008 for ICU 3.8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
