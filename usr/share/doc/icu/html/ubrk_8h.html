<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ICU 3.8: ubrk.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ubrk.h File Reference</h1>C API: <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="utypes_8h-source.html">unicode/utypes.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="uloc_8h-source.html">unicode/uloc.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="utext_8h-source.html">unicode/utext.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="parseerr_8h-source.html">unicode/parseerr.h</a>&quot;</code><br>

<p>
<a href="ubrk_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#7c31c1e5091fb47ab85db522c7536252">UBRK_DONE</a>&nbsp;&nbsp;&nbsp;((int32_t) -1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value indicating all text boundaries have been returned.  <a href="#7c31c1e5091fb47ab85db522c7536252"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#b17dc88e0028fd85c622889eea22a6fa">U_BRK_SAFECLONE_BUFFERSIZE</a>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone().  <a href="#b17dc88e0028fd85c622889eea22a6fa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A text-break iterator.  <a href="#91403765077ce0615043a82d9adef758"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> { <br>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b446d025be7ca2f64dfac303b0a55c0b3">UBRK_CHARACTER</a> =  0, 
<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b17772e8ee70d3de4064c71417c574f36">UBRK_WORD</a> =  1, 
<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b73e81a0d478daeb2c6de8a63cac1070c">UBRK_LINE</a> =  2, 
<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588bb1b31cbd0fb0b298b87cb67da729ba62">UBRK_SENTENCE</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b3d79f0b0db32243e6b85b0b5036f9831">UBRK_TITLE</a> =  4, 
<b>UBRK_COUNT</b> =  5
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The possible types of text boundaries.  <a href="ubrk_8h.html#026dec40289da8261d787daf3baa588b">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a> { <br>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b98229f94661c6289a6497018ef341801a">UBRK_WORD_NONE</a> =  0, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b954839e74f8aa4ffd4ea7b9d86f3de050">UBRK_WORD_NONE_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b93ec03137beddd2ce1d611cc7798b6e74">UBRK_WORD_NUMBER</a> =  100, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b982e563b42b89e0a49c097d40a54c8621">UBRK_WORD_NUMBER_LIMIT</a> =  200, 
<br>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9945eb6dd49881b36d4e2c9f592d97197">UBRK_WORD_LETTER</a> =  200, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b966ad49e358ce8a4fba6d6161ec678dd6">UBRK_WORD_LETTER_LIMIT</a> =  300, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b969f55c4740ce6f96ad9b61d859de201f">UBRK_WORD_KANA</a> =  300, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b97d507a35a3813629c11340a3f0f10fec">UBRK_WORD_KANA_LIMIT</a> =  400, 
<br>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9295f3da24ba9978b5787c1494079c8de">UBRK_WORD_IDEO</a> =  400, 
<a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b98097221024f5c65d58951ad488d57474">UBRK_WORD_IDEO_LIMIT</a> =  500
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum constants for the word break tags returned by getRuleStatus().  <a href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a> { <a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccd6a91dd50489f1fbc5c8c32c29fcc3fee">UBRK_LINE_SOFT</a> =  0, 
<a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccdef314dd1a053a6f2ab57c06f3a3d5f1f">UBRK_LINE_SOFT_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccdd02d1bfcd98382e53c9e83db37fba492">UBRK_LINE_HARD</a> =  100, 
<a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccde767435243d44e5a22c1db90dd3a8f6e">UBRK_LINE_HARD_LIMIT</a> =  200
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum constants for the line break tags returned by getRuleStatus().  <a href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccd">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a> { <a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71ddbcb13addb315fc0814a6fb1284c339">UBRK_SENTENCE_TERM</a> =  0, 
<a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71650703353df53947eb3b996e3e5239f7">UBRK_SENTENCE_TERM_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71ca695be696e0e48676c109de60bcbbdf">UBRK_SENTENCE_SEP</a> =  100, 
<a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71f573420e1d53a811d6c5c4a07a4f5c8e">UBRK_SENTENCE_SEP_LIMIT</a> =  200
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum constants for the sentence break tags returned by getRuleStatus().  <a href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#4e5fd80d818fb4ec23330d8935b2754d">ubrk_open</a> (<a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> type, const char *locale, const UChar *text, int32_t textLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries for a specified locale.  <a href="#4e5fd80d818fb4ec23330d8935b2754d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#11826cb21213916c2d91579b673d8949">ubrk_openRules</a> (const UChar *rules, int32_t rulesLength, const UChar *text, int32_t textLength, <a class="el" href="structUParseError.html">UParseError</a> *parseErr, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries using specified breaking rules.  <a href="#11826cb21213916c2d91579b673d8949"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#6901f59d9c74bc8e16b9994cb1be7679">ubrk_safeClone</a> (const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, void *stackBuffer, int32_t *pBufferSize, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe cloning operation.  <a href="#6901f59d9c74bc8e16b9994cb1be7679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#5e398fb0fe194683a000b3989c041fda">ubrk_close</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a UBreakIterator.  <a href="#5e398fb0fe194683a000b3989c041fda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#8c8a6679a8ce36ba5d035b99748c8339">ubrk_setText</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, const UChar *text, int32_t textLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#8c8a6679a8ce36ba5d035b99748c8339"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#c91bfeb92a3e489e3188f02597f4c9c7">ubrk_setUText</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, <a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#c91bfeb92a3e489e3188f02597f4c9c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#4f8b67527c5c9d9205a3446506ffeefc">ubrk_current</a> (const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the most recently-returned text boundary.  <a href="#4f8b67527c5c9d9205a3446506ffeefc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#17158fccedcf72481eaca61fffab4ce6">ubrk_next</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary following the current text boundary.  <a href="#17158fccedcf72481eaca61fffab4ce6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#318c950f25ee89a66c989feced3a41f0">ubrk_previous</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary preceding the current text boundary.  <a href="#318c950f25ee89a66c989feced3a41f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index of the first character in the text being scanned.  <a href="#2ae638e98af0830b66ff058b48e7dbcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index immediately <em>beyond</em> the last character in the text being scanned.  <a href="#24ffb5cee86ffe1ee8aa0d53093b352f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ccaaccc55135961f45541bcbab580f9d">ubrk_preceding</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary preceding the specified offset.  <a href="#ccaaccc55135961f45541bcbab580f9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#4724e6d07ea2f27b99a1bba60e4ef76c">ubrk_following</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary following the specified offset.  <a href="#4724e6d07ea2f27b99a1bba60e4ef76c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a> (int32_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a locale for which text breaking information is available.  <a href="#12fc845896682221749f03e7dc21e3e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#8b587f3b0df1b680f4ca3f1d1f151f7e">ubrk_countAvailable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine how many locales have text breaking information available.  <a href="#8b587f3b0df1b680f4ca3f1d1f151f7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#701db54fd2c91c07490cb02ebdd54fa6">ubrk_isBoundary</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, int32_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the specfied position is a boundary position.  <a href="#701db54fd2c91c07490cb02ebdd54fa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#4314a5dd63efde9b372ded64b6f0c732">ubrk_getRuleStatus</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status from the break rule that determined the most recently returned break position.  <a href="#4314a5dd63efde9b372ded64b6f0c732"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#cf355cf304090ca6efb10c4318bde45e">ubrk_getRuleStatusVec</a> (<a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the statuses from the break rules that determined the most recently returned break position.  <a href="#cf355cf304090ca6efb10c4318bde45e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#d95a44383cba60e20188025ab18c09fe">ubrk_getLocaleByType</a> (const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *bi, <a class="el" href="uloc_8h.html#df053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the locale of the break iterator.  <a href="#d95a44383cba60e20188025ab18c09fe"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
C API: <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. 
<p>
<h2><a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> C API </h2>
<p>
The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> C API defines methods for finding the location of boundaries in text. Pointer to a UBreakIterator maintain a current position and scan over text returning the index of characters where boundaries occur. <p>
Line boundary analysis determines where a text string can be broken when line-wrapping. The mechanism correctly handles punctuation and hyphenated words. <p>
Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks such as quotation marks and parentheses. <p>
Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides. <p>
Character boundary analysis allows users to interact with characters as they expect to, for example, when moving the cursor through a text string. Character boundary analysis provides correct navigation of through character strings, regardless of how the character is stored. For example, an accented character might be stored as a base character and a diacritical mark. What users consider to be a character can differ between languages. <p>
Title boundary analysis locates all positions, typically starts of words, that should be set to Title Case when title casing the text. <p>
The text boundary positions are found according to the rules described in Unicode Standard Annex #29, Text Boundaries, and Unicode Standard Annex #14, Line Breaking Properties. These are available at <a href="http://www.unicode.org/reports/tr14/">http://www.unicode.org/reports/tr14/</a> and <a href="http://www.unicode.org/reports/tr29/.">http://www.unicode.org/reports/tr29/.</a> <p>
In addition to the plain C API defined in this header file, an object oriented C++ API with equivalent functionality is defined in the file <a class="el" href="brkiter_8h.html" title="C++ API: Break Iterator.">brkiter.h</a>. <p>
Code snippits illustrating the use of the Break Iterator APIs are available in the ICU User Guide, <a href="http://icu-project.org/userguide/boundaryAnalysis.html">http://icu-project.org/userguide/boundaryAnalysis.html</a> and in the sample program icu/source/samples/break/break.cpp" 
<p>Definition in file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="b17dc88e0028fd85c622889eea22a6fa"></a><!-- doxytag: member="ubrk.h::U_BRK_SAFECLONE_BUFFERSIZE" ref="b17dc88e0028fd85c622889eea22a6fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_BRK_SAFECLONE_BUFFERSIZE&nbsp;&nbsp;&nbsp;512          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone(). 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000420">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00270">270</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c31c1e5091fb47ab85db522c7536252"></a><!-- doxytag: member="ubrk.h::UBRK_DONE" ref="7c31c1e5091fb47ab85db522c7536252" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBRK_DONE&nbsp;&nbsp;&nbsp;((int32_t) -1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value indicating all text boundaries have been returned. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000413">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00114">114</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="91403765077ce0615043a82d9adef758"></a><!-- doxytag: member="ubrk.h::UBreakIterator" ref="91403765077ce0615043a82d9adef758" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A text-break iterator. 
<p>
For usage in C programs. Opaque type representing an ICU Break iterator object. <dl compact><dt><b><a class="el" href="stable.html#_stable000411">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00025">25</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="026dec40289da8261d787daf3baa588b"></a><!-- doxytag: member="ubrk.h::UBreakIteratorType" ref="026dec40289da8261d787daf3baa588b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The possible types of text boundaries. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000412">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="026dec40289da8261d787daf3baa588b446d025be7ca2f64dfac303b0a55c0b3"></a><!-- doxytag: member="UBRK_CHARACTER" ref="026dec40289da8261d787daf3baa588b446d025be7ca2f64dfac303b0a55c0b3" args="" -->UBRK_CHARACTER</em>&nbsp;</td><td>
Character breaks. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000437">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="026dec40289da8261d787daf3baa588b17772e8ee70d3de4064c71417c574f36"></a><!-- doxytag: member="UBRK_WORD" ref="026dec40289da8261d787daf3baa588b17772e8ee70d3de4064c71417c574f36" args="" -->UBRK_WORD</em>&nbsp;</td><td>
Word breaks. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000438">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="026dec40289da8261d787daf3baa588b73e81a0d478daeb2c6de8a63cac1070c"></a><!-- doxytag: member="UBRK_LINE" ref="026dec40289da8261d787daf3baa588b73e81a0d478daeb2c6de8a63cac1070c" args="" -->UBRK_LINE</em>&nbsp;</td><td>
Line breaks. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000439">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="026dec40289da8261d787daf3baa588bb1b31cbd0fb0b298b87cb67da729ba62"></a><!-- doxytag: member="UBRK_SENTENCE" ref="026dec40289da8261d787daf3baa588bb1b31cbd0fb0b298b87cb67da729ba62" args="" -->UBRK_SENTENCE</em>&nbsp;</td><td>
Sentence breaks. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000440">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="026dec40289da8261d787daf3baa588b3d79f0b0db32243e6b85b0b5036f9831"></a><!-- doxytag: member="UBRK_TITLE" ref="026dec40289da8261d787daf3baa588b3d79f0b0db32243e6b85b0b5036f9831" args="" -->UBRK_TITLE</em>&nbsp;</td><td>
Title Case breaks The iterator created using this type locates title boundaries as described for Unicode 3.2 only. 
<p>
For Unicode 4.0 and above title boundary iteration, please use Word Boundary iterator.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>ICU 2.8 Use the word break iterator for titlecasing for Unicode 4 and later. </dd></dl>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00087">87</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8de005c411b5e5306850f4246d1d7ccd"></a><!-- doxytag: member="ubrk.h::ULineBreakTag" ref="8de005c411b5e5306850f4246d1d7ccd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum constants for the line break tags returned by getRuleStatus(). 
<p>
A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. <dl compact><dt><b><a class="el" href="stable.html#_stable000415">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="8de005c411b5e5306850f4246d1d7ccd6a91dd50489f1fbc5c8c32c29fcc3fee"></a><!-- doxytag: member="UBRK_LINE_SOFT" ref="8de005c411b5e5306850f4246d1d7ccd6a91dd50489f1fbc5c8c32c29fcc3fee" args="" -->UBRK_LINE_SOFT</em>&nbsp;</td><td>
Tag value for soft line breaks, positions at which a line break is acceptable but not required. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8de005c411b5e5306850f4246d1d7ccdef314dd1a053a6f2ab57c06f3a3d5f1f"></a><!-- doxytag: member="UBRK_LINE_SOFT_LIMIT" ref="8de005c411b5e5306850f4246d1d7ccdef314dd1a053a6f2ab57c06f3a3d5f1f" args="" -->UBRK_LINE_SOFT_LIMIT</em>&nbsp;</td><td>
Upper bound for soft line breaks. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8de005c411b5e5306850f4246d1d7ccdd02d1bfcd98382e53c9e83db37fba492"></a><!-- doxytag: member="UBRK_LINE_HARD" ref="8de005c411b5e5306850f4246d1d7ccdd02d1bfcd98382e53c9e83db37fba492" args="" -->UBRK_LINE_HARD</em>&nbsp;</td><td>
Tag value for a hard, or mandatory line break. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8de005c411b5e5306850f4246d1d7ccde767435243d44e5a22c1db90dd3a8f6e"></a><!-- doxytag: member="UBRK_LINE_HARD_LIMIT" ref="8de005c411b5e5306850f4246d1d7ccde767435243d44e5a22c1db90dd3a8f6e" args="" -->UBRK_LINE_HARD_LIMIT</em>&nbsp;</td><td>
Upper bound for hard line breaks. 
<p>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00158">158</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d03d8e27f121bcf11eaed0a288786a71"></a><!-- doxytag: member="ubrk.h::USentenceBreakTag" ref="d03d8e27f121bcf11eaed0a288786a71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#d03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum constants for the sentence break tags returned by getRuleStatus(). 
<p>
A range of values is defined for each category of sentence, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. <dl compact><dt><b><a class="el" href="stable.html#_stable000416">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="d03d8e27f121bcf11eaed0a288786a71ddbcb13addb315fc0814a6fb1284c339"></a><!-- doxytag: member="UBRK_SENTENCE_TERM" ref="d03d8e27f121bcf11eaed0a288786a71ddbcb13addb315fc0814a6fb1284c339" args="" -->UBRK_SENTENCE_TERM</em>&nbsp;</td><td>
Tag value for for sentences ending with a sentence terminator ('. 
<p>
', '?', '!', etc.) character, possibly followed by a hard separator (CR, LF, PS, etc.) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="d03d8e27f121bcf11eaed0a288786a71650703353df53947eb3b996e3e5239f7"></a><!-- doxytag: member="UBRK_SENTENCE_TERM_LIMIT" ref="d03d8e27f121bcf11eaed0a288786a71650703353df53947eb3b996e3e5239f7" args="" -->UBRK_SENTENCE_TERM_LIMIT</em>&nbsp;</td><td>
Upper bound for tags for sentences ended by sentence terminators. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="d03d8e27f121bcf11eaed0a288786a71ca695be696e0e48676c109de60bcbbdf"></a><!-- doxytag: member="UBRK_SENTENCE_SEP" ref="d03d8e27f121bcf11eaed0a288786a71ca695be696e0e48676c109de60bcbbdf" args="" -->UBRK_SENTENCE_SEP</em>&nbsp;</td><td>
Tag value for for sentences that do not contain an ending sentence terminator ('. 
<p>
', '?', '!', etc.) character, but are ended only by a hard separator (CR, LF, PS, etc.) or end of input. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="d03d8e27f121bcf11eaed0a288786a71f573420e1d53a811d6c5c4a07a4f5c8e"></a><!-- doxytag: member="UBRK_SENTENCE_SEP_LIMIT" ref="d03d8e27f121bcf11eaed0a288786a71f573420e1d53a811d6c5c4a07a4f5c8e" args="" -->UBRK_SENTENCE_SEP_LIMIT</em>&nbsp;</td><td>
Upper bound for tags for sentences ended by a separator. 
<p>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00180">180</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b9"></a><!-- doxytag: member="ubrk.h::UWordBreak" ref="f9836cc79482f82ac12eefb1f70b14b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#f9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum constants for the word break tags returned by getRuleStatus(). 
<p>
A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. <dl compact><dt><b><a class="el" href="stable.html#_stable000414">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b98229f94661c6289a6497018ef341801a"></a><!-- doxytag: member="UBRK_WORD_NONE" ref="f9836cc79482f82ac12eefb1f70b14b98229f94661c6289a6497018ef341801a" args="" -->UBRK_WORD_NONE</em>&nbsp;</td><td>
Tag value for "words" that do not fit into any of other categories. 
<p>
Includes spaces and most punctuation. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b954839e74f8aa4ffd4ea7b9d86f3de050"></a><!-- doxytag: member="UBRK_WORD_NONE_LIMIT" ref="f9836cc79482f82ac12eefb1f70b14b954839e74f8aa4ffd4ea7b9d86f3de050" args="" -->UBRK_WORD_NONE_LIMIT</em>&nbsp;</td><td>
Upper bound for tags for uncategorized words. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b93ec03137beddd2ce1d611cc7798b6e74"></a><!-- doxytag: member="UBRK_WORD_NUMBER" ref="f9836cc79482f82ac12eefb1f70b14b93ec03137beddd2ce1d611cc7798b6e74" args="" -->UBRK_WORD_NUMBER</em>&nbsp;</td><td>
Tag value for words that appear to be numbers, lower limit. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b982e563b42b89e0a49c097d40a54c8621"></a><!-- doxytag: member="UBRK_WORD_NUMBER_LIMIT" ref="f9836cc79482f82ac12eefb1f70b14b982e563b42b89e0a49c097d40a54c8621" args="" -->UBRK_WORD_NUMBER_LIMIT</em>&nbsp;</td><td>
Tag value for words that appear to be numbers, upper limit. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b9945eb6dd49881b36d4e2c9f592d97197"></a><!-- doxytag: member="UBRK_WORD_LETTER" ref="f9836cc79482f82ac12eefb1f70b14b9945eb6dd49881b36d4e2c9f592d97197" args="" -->UBRK_WORD_LETTER</em>&nbsp;</td><td>
Tag value for words that contain letters, excluding hiragana, katakana or ideographic characters, lower limit. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b966ad49e358ce8a4fba6d6161ec678dd6"></a><!-- doxytag: member="UBRK_WORD_LETTER_LIMIT" ref="f9836cc79482f82ac12eefb1f70b14b966ad49e358ce8a4fba6d6161ec678dd6" args="" -->UBRK_WORD_LETTER_LIMIT</em>&nbsp;</td><td>
Tag value for words containing letters, upper limit. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b969f55c4740ce6f96ad9b61d859de201f"></a><!-- doxytag: member="UBRK_WORD_KANA" ref="f9836cc79482f82ac12eefb1f70b14b969f55c4740ce6f96ad9b61d859de201f" args="" -->UBRK_WORD_KANA</em>&nbsp;</td><td>
Tag value for words containing kana characters, lower limit. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b97d507a35a3813629c11340a3f0f10fec"></a><!-- doxytag: member="UBRK_WORD_KANA_LIMIT" ref="f9836cc79482f82ac12eefb1f70b14b97d507a35a3813629c11340a3f0f10fec" args="" -->UBRK_WORD_KANA_LIMIT</em>&nbsp;</td><td>
Tag value for words containing kana characters, upper limit. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b9295f3da24ba9978b5787c1494079c8de"></a><!-- doxytag: member="UBRK_WORD_IDEO" ref="f9836cc79482f82ac12eefb1f70b14b9295f3da24ba9978b5787c1494079c8de" args="" -->UBRK_WORD_IDEO</em>&nbsp;</td><td>
Tag value for words containing ideographic characters, lower limit. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f9836cc79482f82ac12eefb1f70b14b98097221024f5c65d58951ad488d57474"></a><!-- doxytag: member="UBRK_WORD_IDEO_LIMIT" ref="f9836cc79482f82ac12eefb1f70b14b98097221024f5c65d58951ad488d57474" args="" -->UBRK_WORD_IDEO_LIMIT</em>&nbsp;</td><td>
Tag value for words containing ideographic characters, upper limit. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h-source.html#l00125">125</a> of file <a class="el" href="ubrk_8h-source.html">ubrk.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="5e398fb0fe194683a000b3989c041fda"></a><!-- doxytag: member="ubrk.h::ubrk_close" ref="5e398fb0fe194683a000b3989c041fda" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a UBreakIterator. 
<p>
Once closed, a UBreakIterator may no longer be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to close. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000421">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b587f3b0df1b680f4ca3f1d1f151f7e"></a><!-- doxytag: member="ubrk.h::ubrk_countAvailable" ref="8b587f3b0df1b680f4ca3f1d1f151f7e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_countAvailable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine how many locales have text breaking information available. 
<p>
This function is most useful as determining the loop ending condition for calls to <a class="el" href="ubrk_8h.html#12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of locales for which text breaking information is available. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#12fc845896682221749f03e7dc21e3e0" title="Get a locale for which text breaking information is available.">ubrk_getAvailable</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000432">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f8b67527c5c9d9205a3446506ffeefc"></a><!-- doxytag: member="ubrk.h::ubrk_current" ref="4f8b67527c5c9d9205a3446506ffeefc" args="(const UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_current           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the most recently-returned text boundary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character index most recently returned by <a class="el" href="ubrk_8h.html#17158fccedcf72481eaca61fffab4ce6">ubrk_next</a>, <a class="el" href="ubrk_8h.html#318c950f25ee89a66c989feced3a41f0">ubrk_previous</a>, <a class="el" href="ubrk_8h.html#2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a>, or <a class="el" href="ubrk_8h.html#24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a>. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000424">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ae638e98af0830b66ff058b48e7dbcd"></a><!-- doxytag: member="ubrk.h::ubrk_first" ref="2ae638e98af0830b66ff058b48e7dbcd" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_first           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the index of the first character in the text being scanned. 
<p>
This is not always the same as index 0 of the text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character index of the first character in the text being scanned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#24ffb5cee86ffe1ee8aa0d53093b352f" title="Determine the index immediately beyond the last character in the text being scanned...">ubrk_last</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000427">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="4724e6d07ea2f27b99a1bba60e4ef76c"></a><!-- doxytag: member="ubrk.h::ubrk_following" ref="4724e6d07ea2f27b99a1bba60e4ef76c" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_following           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the text boundary following the specified offset. 
<p>
The value returned is always greater than offset, or UBRK_DONE. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset to begin scanning. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text boundary following offset, or UBRK_DONE. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#ccaaccc55135961f45541bcbab580f9d" title="Determine the text boundary preceding the specified offset.">ubrk_preceding</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000430">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="12fc845896682221749f03e7dc21e3e0"></a><!-- doxytag: member="ubrk.h::ubrk_getAvailable" ref="12fc845896682221749f03e7dc21e3e0" args="(int32_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getAvailable           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a locale for which text breaking information is available. 
<p>
A UBreakIterator in a locale returned by this function will perform the correct text breaking for the locale. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the desired locale. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A locale for which number text breaking information is available, or 0 if none. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#8b587f3b0df1b680f4ca3f1d1f151f7e" title="Determine how many locales have text breaking information available.">ubrk_countAvailable</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000431">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d95a44383cba60e20188025ab18c09fe"></a><!-- doxytag: member="ubrk.h::ubrk_getLocaleByType" ref="d95a44383cba60e20188025ab18c09fe" args="(const UBreakIterator *bi, ULocDataLocaleType type, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getLocaleByType           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uloc_8h.html#df053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the locale of the break iterator. 
<p>
You can choose between the valid and the actual locale. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>break iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>locale type (valid or actual) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>error code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>locale string </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000436">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div><p>
<a class="anchor" name="4314a5dd63efde9b372ded64b6f0c732"></a><!-- doxytag: member="ubrk.h::ubrk_getRuleStatus" ref="4314a5dd63efde9b372ded64b6f0c732" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the status from the break rule that determined the most recently returned break position. 
<p>
The values appear in the rule source within brackets, {123}, for example. For rules that do not specify a status, a default value of 0 is returned. <p>
For word break iterators, the possible values are defined in enum UWordBreak. <dl compact><dt><b><a class="el" href="stable.html#_stable000434">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf355cf304090ca6efb10c4318bde45e"></a><!-- doxytag: member="ubrk.h::ubrk_getRuleStatusVec" ref="cf355cf304090ca6efb10c4318bde45e" args="(UBreakIterator *bi, int32_t *fillInVec, int32_t capacity, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatusVec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the statuses from the break rules that determined the most recently returned break position. 
<p>
The values appear in the rule source within brackets, {123}, for example. The default status value for rules that do not explicitly provide one is zero. <p>
For word break iterators, the possible values are defined in enum UWordBreak. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fillInVec</em>&nbsp;</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attemtping to store any values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives error codes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of rule status values from rules that determined the most recent boundary returned by the break iterator. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000435">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="701db54fd2c91c07490cb02ebdd54fa6"></a><!-- doxytag: member="ubrk.h::ubrk_isBoundary" ref="701db54fd2c91c07490cb02ebdd54fa6" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> ubrk_isBoundary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the specfied position is a boundary position. 
<p>
As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000433">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="24ffb5cee86ffe1ee8aa0d53093b352f"></a><!-- doxytag: member="ubrk.h::ubrk_last" ref="24ffb5cee86ffe1ee8aa0d53093b352f" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_last           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the index immediately <em>beyond</em> the last character in the text being scanned. 
<p>
This is not the same as the last character. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character offset immediately <em>beyond</em> the last character in the text being scanned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#2ae638e98af0830b66ff058b48e7dbcd" title="Determine the index of the first character in the text being scanned.">ubrk_first</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000428">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="17158fccedcf72481eaca61fffab4ce6"></a><!-- doxytag: member="ubrk.h::ubrk_next" ref="17158fccedcf72481eaca61fffab4ce6" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the text boundary following the current text boundary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character index of the next text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#318c950f25ee89a66c989feced3a41f0" title="Determine the text boundary preceding the current text boundary.">ubrk_previous</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000425">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e5fd80d818fb4ec23330d8935b2754d"></a><!-- doxytag: member="ubrk.h::ubrk_open" ref="4e5fd80d818fb4ec23330d8935b2754d" args="(UBreakIteratorType type, const char *locale, const UChar *text, int32_t textLength, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a>* ubrk_open           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a new UBreakIterator for locating text boundaries for a specified locale. 
<p>
A UBreakIterator may be used for detecting character, line, word, and sentence breaks in text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of UBreakIterator to open: one of UBRK_CHARACTER, UBRK_WORD, UBRK_LINE, UBRK_SENTENCE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>The locale specifying the text-breaking conventions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be iterated over. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UBreakIterator for the specified locale. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#11826cb21213916c2d91579b673d8949" title="Open a new UBreakIterator for locating text boundaries using specified breaking rules...">ubrk_openRules</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000417">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="11826cb21213916c2d91579b673d8949"></a><!-- doxytag: member="ubrk.h::ubrk_openRules" ref="11826cb21213916c2d91579b673d8949" args="(const UChar *rules, int32_t rulesLength, const UChar *text, int32_t textLength, UParseError *parseErr, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a>* ubrk_openRules           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>rulesLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> *&nbsp;</td>
          <td class="paramname"> <em>parseErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a new UBreakIterator for locating text boundaries using specified breaking rules. 
<p>
The rule syntax is ... (TBD) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rules</em>&nbsp;</td><td>A set of rules specifying the text breaking conventions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rulesLength</em>&nbsp;</td><td>The number of characters in rules, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be iterated over. May be null, in which case <a class="el" href="ubrk_8h.html#8c8a6679a8ce36ba5d035b99748c8339" title="Sets an existing iterator to point to a new piece of text.">ubrk_setText()</a> is used to specify the text to be iterated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parseErr</em>&nbsp;</td><td>Receives position and context information for any syntax errors detected while parsing the rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UBreakIterator for the specified rules. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#4e5fd80d818fb4ec23330d8935b2754d" title="Open a new UBreakIterator for locating text boundaries for a specified locale.">ubrk_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000418">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccaaccc55135961f45541bcbab580f9d"></a><!-- doxytag: member="ubrk.h::ubrk_preceding" ref="ccaaccc55135961f45541bcbab580f9d" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_preceding           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the text boundary preceding the specified offset. 
<p>
The value returned is always smaller than offset, or UBRK_DONE. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset to begin scanning. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The text boundary preceding offset, or UBRK_DONE. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#4724e6d07ea2f27b99a1bba60e4ef76c" title="Determine the text boundary following the specified offset.">ubrk_following</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000429">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="318c950f25ee89a66c989feced3a41f0"></a><!-- doxytag: member="ubrk.h::ubrk_previous" ref="318c950f25ee89a66c989feced3a41f0" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_previous           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the text boundary preceding the current text boundary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The character index of the preceding text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#17158fccedcf72481eaca61fffab4ce6" title="Determine the text boundary following the current text boundary.">ubrk_next</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000426">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6901f59d9c74bc8e16b9994cb1be7679"></a><!-- doxytag: member="ubrk.h::ubrk_safeClone" ref="6901f59d9c74bc8e16b9994cb1be7679" args="(const UBreakIterator *bi, void *stackBuffer, int32_t *pBufferSize, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a>* ubrk_safeClone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread safe cloning operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>iterator to be cloned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. Clients can use the U_BRK_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBufferSize</em>&nbsp;</td><td>pointer to size of allocated space. If *pBufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If *pBufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the new clone </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000419">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c8a6679a8ce36ba5d035b99748c8339"></a><!-- doxytag: member="ubrk.h::ubrk_setText" ref="8c8a6679a8ce36ba5d035b99748c8339" args="(UBreakIterator *bi, const UChar *text, int32_t textLength, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an existing iterator to point to a new piece of text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The length of the text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000422">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c91bfeb92a3e489e3188f02597f4c9c7"></a><!-- doxytag: member="ubrk.h::ubrk_setUText" ref="c91bfeb92a3e489e3188f02597f4c9c7" args="(UBreakIterator *bi, UText *text, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setUText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#91403765077ce0615043a82d9adef758">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an existing iterator to point to a new piece of text. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be set. This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the <a class="el" href="structUText.html" title="UText struct.">UText</a> that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000423">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 28 17:50:01 2008 for ICU 3.8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
